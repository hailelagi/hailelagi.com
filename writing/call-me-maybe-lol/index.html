<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=”og:title” content="Call Me Maybe? | Haile (ሐይሌ)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Call Me Maybe? | Haile (ሐይሌ)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>Call Me Maybe?</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href=/bookshelf title=bookshelf>bookshelf</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=writing>writing</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Call Me Maybe?</h1><time>August 11, 2024</time><meta name=twitter:card content="summary">
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><p>What I learned <a href=https://github.com/hailelagi/gossip-glomers>solving</a> the <a href=https://www.fly.io/dist-sys>fly.io distributed systems challenges</a>.</p><p>The title of this post is inspired by <a href=https://aphyr.com/posts/316-call-me-maybe-etcd-and-consul>kyle kingsbury&rsquo; series of articles like this one</a> and <a href=https://aphyr.com/posts/315-call-me-maybe-rabbitmq>this one</a> and of course:</p><iframe src=https://open.spotify.com/embed/track/20I6sIOMTCkB6w7ryavxtO width=100% height=380 frameborder=0 allowtransparency=true allow=encrypted-media></iframe><aside id=toc><h4>A lay of the land</h4><nav id=TableOfContents><ul><li><a href=#1-echo>1. Echo</a></li><li><a href=#2-unique-id-generation>2. Unique ID Generation</a></li><li><a href=#3-broadcast>3. Broadcast</a></li><li><a href=#4-grow-only-counter>4. Grow-Only Counter</a></li><li><a href=#5-kafka-style-log>5. Kafka-Style Log</a></li><li><a href=#6-totally-available-transactions>6. Totally-Available Transactions</a></li><li><a href=#7-testing-model-checkers-and-simulators>7. Testing, Model Checkers and Simulators</a><ul><li><a href=#references>References</a></li></ul></li></ul></nav></aside><h2 id=1-echo>1. Echo</h2><p>saying hello world! but distributed systems style, it&rsquo;s mostly boilerplate setup,
reading the maelstrom docs and the go client docs, we instantiate a maelstrom node/binary, define an RPC style handler and return messages:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=o>:=</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nf>NewNode</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Register a handler for the &#34;echo&#34; message that responds with an &#34;echo_ok&#34;.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>n</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=s>&#34;echo&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>msg</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Unmarshal the message body as an loosely-typed map.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kd>var</span> <span class=nx>body</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Update the message type.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>body</span><span class=p>[</span><span class=s>&#34;type&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;echo_ok&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Echo the original message back with the updated message type.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Execute the node&#39;s message loop. This will run until STDIN is closed.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nf>Run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;ERROR: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=2-unique-id-generation>2. Unique ID Generation</h2><p>In a single node/computer, generation of unique ids is typically achieved using a growing monontonic sequence such as a counter or the system clock.</p><p>In the view of a distributed system where each node could increment this counter simultaneously and <a href=https://tigerbeetle.com/blog/three-clocks-are-better-than-one>the system clock is unreliable</a> there needs to be some way of solving this <a href="https://www.youtube.com/watch?v=mAyW-4LeXZo">global clock synchronisation problem</a> of not only skewing different &ldquo;times&rdquo; but logical ordering of events. What to do? We also want to prevent the need to exchange messages or co-ordination so lamport clocks are out!</p><ol><li>A pseudo logical event clock where we can represent causal dependencies as combinations of properties of our system for e.g the system clock + orignating node id + a random request id(tie breaker). Luckily for this challenge there aren&rsquo;t requirements for <strong>space</strong> or <strong>ordering</strong> or <strong>causality</strong>, only <strong>global uniqueness</strong>, which is naive but isn&rsquo;t too far off more sophisticated schemes <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>genNaive</span><span class=p>(</span><span class=nx>nodeID</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>requestID</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>FormatInt</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Int63n</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>sequenceId</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>FormatInt</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixMicro</span><span class=p>(),</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>originId</span> <span class=o>:=</span> <span class=nx>nodeID</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>identity</span> <span class=o>:=</span> <span class=nx>originId</span> <span class=o>+</span> <span class=nx>requestID</span> <span class=o>+</span> <span class=nx>sequenceId</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>ParseInt</span><span class=p>(</span><span class=nx>identity</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>64</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>id</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li><p>hash a seed over a really large key space (2**128 - 1) - a uuid.</p></li><li><p>The use of a central authority, such as an atomic clock + GPS and/or other clever distributed algorithms<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> provided by a <a href=https://cloud.google.com/spanner/docs/true-time-external-consistency>time server(s)</a>.</p></li></ol><h2 id=3-broadcast>3. Broadcast</h2><p>Our first &ldquo;official&rdquo; distributed algorithm! a way to gossip information to nodes. Incrementally we scaffold basic messaging,
sending data efficiently, simulating network partitions, variable latencies and interesting node topologies!</p><p>We keep all data we&rsquo;ve seen in-memory in a simple &ldquo;store&rdquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>store</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>index</span> <span class=kd>map</span><span class=p>[</span><span class=kt>float64</span><span class=p>]</span><span class=kt>bool</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span>   <span class=p>[]</span><span class=kt>float64</span>
</span></span><span class=line><span class=cl>	<span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a session is a wrapper instance of a maelstrom node
</span></span></span><span class=line><span class=cl><span class=c1>// that can read/write from a single store and `handle` messages
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>session</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>node</span>    <span class=o>*</span><span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>store</span>   <span class=o>*</span><span class=nx>store</span>
</span></span><span class=line><span class=cl>	<span class=nx>retries</span> <span class=kd>chan</span> <span class=nx>retry</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>reading, we simply take a <code>read</code> lock, respond with what&rsquo;s in our <code>log</code> so far.</p><p>If we get a <code>broadcast</code> message we concurrently attempt to send it to all our neighbours, excluding ourself, store it in <code>log</code> and <code>index</code> so we can test if we&rsquo;ve seen this message before and short circuit duplicate broadcast replies:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// spam everyone in this network we know of, and so on...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>dest</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>n</span><span class=p>.</span><span class=nf>NodeIDs</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>dest</span> <span class=o>==</span> <span class=nx>n</span><span class=p>.</span><span class=nf>ID</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>continue</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>dest</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>400</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>bgd</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>bgd</span><span class=p>,</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nf>SyncRPC</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>dest</span><span class=p>,</span> <span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// failure detection up next!
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}(</span><span class=nx>dest</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span></code></pre></div><p>Our failure detection algorithm is a simple FIFO queue using go&rsquo;s channels, for the un-initiated in go-ism, it&rsquo;s conceptually an <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.22.3:src/runtime/chan.go;l=33">&ldquo;atomic circular buffer&rdquo;</a>, if that doesn&rsquo;t mean much &ndash; it&rsquo;s a &lsquo;concurrent safe queue&rsquo;, so we can handle network partitions and variable latency async!
We send messages into a buffered channel, in our else block and read it (if/when) we have to retry in a seperate goroutine(s):</p><pre tabindex=0><code>s.retries &lt;- Retry{body: body, dest: dest, attempt: 20, err: err}
</code></pre><p>we guess-timate a queue size (I&rsquo;m not 100% about this bit lmk if I&rsquo;m wrong!):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> little&#39;s law: L (num units) = arrival rate * wait time
</span></span></span><span class=line><span class=cl><span class=cm> rate == 100 msgs/sec assuming efficient workload,
</span></span></span><span class=line><span class=cl><span class=cm> latency/wait mininum = 100ms, 400ms average
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> 100 * 0.4 = 40 msgs per request * 25 - 1(self) nodes 
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> = 960 queue size, will use ~1000
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>retries</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>retry</span><span class=p>,</span> <span class=mi>1000</span><span class=p>)</span>
</span></span></code></pre></div><p>The spurious errors and on/off successes and failures making this were&mldr; interesting to debug! non-deterministic systems are&mldr; something.
Anyway, a few <code>failureDetector</code> go routines are spawned and sleep until messages are in the queue.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>runtime</span><span class=p>.</span><span class=nf>NumCPU</span><span class=p>();</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=nf>failureDetector</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>What suprised me was the tweaking of the <code>deadline</code> a longer deadline would lead to consistently more reliable delivery vs retrying in smaller intervals &ndash; this should have been obvious, but I only understood this in hindsight.</p><blockquote><p>there’s always a trade-off between wrongly suspecting alive processes as dead (producing false-positives), and delaying marking an unresponsive process as dead, giving it the benefit of doubt and expecting it to respond eventually (producing false-negatives).</p></blockquote><p>Which is to say a shorter deadline can make a more <em>efficient</em> algorithm with lower latency, but it&rsquo;s less <em>accurate</em> and detects down nodes less reliably leading to more retry storms and eventually possibly overwhelming the partial async timing model assumptions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// a naive failure detector :)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>failureDetector</span><span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>session</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>atttempts</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>r</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span><span class=p>.</span><span class=nx>retries</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=nx>r</span> <span class=o>:=</span> <span class=nx>r</span>
</span></span><span class=line><span class=cl>	  <span class=nx>atttempts</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	  <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>retry</span> <span class=nx>retry</span><span class=p>,</span> <span class=nx>attempts</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		  <span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>800</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		  <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		  <span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		  <span class=k>defer</span> <span class=nx>attempts</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		  <span class=nx>retry</span><span class=p>.</span><span class=nx>attempt</span><span class=o>--</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		  <span class=k>if</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>attempt</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			  <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>SyncRPC</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>dest</span><span class=p>,</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			  <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				  <span class=k>return</span>
</span></span><span class=line><span class=cl>			  <span class=p>}</span>
</span></span><span class=line><span class=cl>			  <span class=nx>s</span><span class=p>.</span><span class=nx>retries</span> <span class=o>&lt;-</span> <span class=nx>retry</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			  <span class=nx>log</span><span class=p>.</span><span class=nf>SetOutput</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			  <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;dead letter message slip loss beyond tolerance %v&#34;</span><span class=p>,</span> <span class=nx>retry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>r</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>atttempts</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=nx>atttempts</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>A perfect timeout-based failure detector exists only in a synchronous crash-stop system with reliable
links; in a partially synchronous system, a perfect failure detector does not exist</p><p>&ndash; <a href=https://www.cl.cam.ac.uk/teaching/2122/ConcDisSys/dist-sys-notes.pdf>https://www.cl.cam.ac.uk/teaching/2122/ConcDisSys/dist-sys-notes.pdf</a></p></blockquote><p>and finally we optimise! we&rsquo;re sending far too many messages and flooding the entire network! even if it&rsquo;s impossible to be both accurate and fast, we try anyway &ndash; gotta get those p99s up! there&rsquo;s a hint about network topology so let&rsquo;s re-examine that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>neighbors</span> <span class=p>[]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>session</span><span class=p>)</span> <span class=nf>topologyHandler</span><span class=p>(</span><span class=nx>msg</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>body</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>self</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>ID</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>topology</span> <span class=o>:=</span> <span class=nx>body</span><span class=p>[</span><span class=s>&#34;topology&#34;</span><span class=p>].(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>neighbors</span> <span class=p>=</span> <span class=nx>topology</span><span class=p>[</span><span class=nx>self</span><span class=p>].([]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>{</span><span class=s>&#34;type&#34;</span><span class=p>:</span> <span class=s>&#34;topology_ok&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>For this bit, I had to draw up the messsaging flow of the network topology on pen and paper. First I tried to send only to immediately connected neighbours. For example in a 5 node cluster of <code>a, b, c, d, e</code> a would neighbour <code>b, c</code> and so on forming a grid:</p><p>This is <code>O(n) * sqrt(n)</code>:</p><pre tabindex=0><code>a ++ b ++ d
+    +    +
c ++ e  /
</code></pre><p>instead of <code>a</code> spamming <code>b</code>, <code>c</code>, <code>d</code> and <code>e</code> and so on which is <code>O(n)^2</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gd>-- // spam everyone in this network we know of, and so on...
</span></span></span><span class=line><span class=cl><span class=gd>-- for _, dest := range n.NodeIDs()
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>++ // send to our &#34;overlay&#34; neighbors only
</span></span></span><span class=line><span class=cl><span class=gi>++ for _, dest := range neighbors
</span></span></span></code></pre></div><p><a href=https://learning.oreilly.com/library/view/database-internals/9781492040330/ch12.html>Database Internals chapter 12</a> and the <a href=https://github.com/jepsen-io/maelstrom/blob/main/doc/03-broadcast/02-performance.md>maelstrom docs</a> were also super helpful on where to go about exploring options, network topologies for broadcast are a deep topic, so we&rsquo;ll only review a very tiny subset we&rsquo;re interested in:</p><ol><li>a fully connected grid mesh (what we had before) <a href=https://en.wikipedia.org/wiki/Network_topology>to quote wikipedia</a>:</li></ol><blockquote><p>Networks designed with this topology are usually very expensive to set up, but provide a high degree of reliability due to the multiple paths for data that are provided by the large number of redundant links between nodes</p></blockquote><div class=callout-warning>💡
distributed erlang nodes deliver rpc messages as a <a href=https://www.erlang.org/doc/system/distributed.html#node-connections>full loosely connected network</a> by default using a <a href=https://www.erlang.org/doc/apps/kernel/global.html>global process registry</a> if you're managing a small cluster redundant links are fine and welcome, if you can get away with being fully connected -- which isn't possible in a large network. <a href="https://youtu.be/c12cYAUTXXs?t=1745">Whatsapp had a great talk on opt-ing out of this in 2014!</a></div><ol start=2><li>a tree topology - let&rsquo;s revisit <a href=https://en.wikipedia.org/wiki/Minimum_spanning_tree>spanning trees</a>. We&rsquo;re presented with seemingly contradictory goals - fast low-latency and reliable accurate broadcast, in a 25-node cluster with partitioned networks. What to do?</li></ol><p>Let&rsquo;s say each node in a 6 node cluster forms a grid, each possible route from a node to a node:</p><pre tabindex=0><code>a ++ b ++ c
+    +    +
d ++ e ++ f
</code></pre><p>We can construct a &ldquo;temporary overlay&rdquo; over sub portions of this mesh, which is essentially a small tree from the point of view any node say a to its reachable neighbours:</p><pre tabindex=0><code>    b---/e
   /    \f
a /
  \   /d
   \c
    \
</code></pre><p>This tree is weighted by the cost it takes to reach each neighbour and a <em>minimum spanning tree</em> represents the &ldquo;cheapest way there&rdquo;, well now that&rsquo;s one way of efficiently routing messages quickly, latency goes down, but&mldr; our overall protocol is now more brittle. If an &ldquo;important&rdquo; link between small sub-trees is broken the overall protocol is less reliable. Are there hybrid options?</p><blockquote><p>To keep the number of messages low, while allowing quick recovery in case of a connectivity loss, we can mix both approaches — fixed topologies and tree-based broadcast — when the system is in a stable state, and fall back to gossip for failover and system recovery</p></blockquote><p>I briefly discovered but did not implement other interesting hybrid algorithms/protocols <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> <sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> such as PlumTrees(the search term is &ldquo;epidemic Broadcast Trees&rdquo;), <a href=https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf>SWIM</a> used by <a href=https://www.serf.io/docs/internals/gossip.html>Consul&rsquo;s serf</a>, HyParView & HashGraph, and of course <a href=https://github.com/superfly/corrosion>fly.io&rsquo;s corrosion</a> (built specifically for service discovery) or consul&rsquo;s memberlist<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> and more!</p><p>NB: My <a href=https://github.com/hailelagi/gossip-glomers/tree/main/maelstrom-broadcast>final solution</a> isn&rsquo;t as efficient as it could be:</p><p>It&rsquo;s above the minimum target for &ldquo;chattiness&rdquo; ie <code>30</code> vs <code>30.05824</code> <code>msgs-per-op</code> with <code>--topology tree3</code> which is <code>a - [b, c, d]</code>:</p><pre tabindex=0><code> :net {:all {:send-count 55144,
             :recv-count 55144,
             :msg-count 55144,
             :msgs-per-op 32.11648},
       :clients {:send-count 3534, :recv-count 3534, :msg-count 3534},
       :servers {:send-count 51610,
                 :recv-count 51610,
                 :msg-count 51610,
                 :msgs-per-op 30.05824},
       :valid? true},
</code></pre><p>but on target for latency:</p><pre tabindex=0><code>            :stable-latencies {0 0,
                               0.5 148,
                               0.95 354,
                               0.99 420,
                               1 457},
</code></pre><p>This makes sense, we could shave off even more redundant ack messages by using async <code>n.Send</code> which doesn&rsquo;t expect a response/ack, but it makes it more difficult to be able to have timeouts or detect failure reliably a good middle ground is some kind of periodic polling mechanism with a <code>time.Sleep</code> empirically eyeballing what might be a good fit or a more sophisticated probabilistic model like <a href=https://doc.akka.io/docs/akka/current/typed/failure-detector.html>Phi-Accural</a>.</p><p>I think it&rsquo;s good enough as I&rsquo;ve better intuited the trade off here. Maelstrom has a &ldquo;line&rdquo;, &ldquo;grid&rdquo; and several <a href=https://github.com/jepsen-io/maelstrom/blob/main/doc/03-broadcast/02-performance.md#broadcast-latency>spanning tree topologies</a> by using one kind of network for example across the &ldquo;line&rdquo;:</p><pre tabindex=0><code>a ++ b ++ c ++ d ++ e ++ f
</code></pre><p>or &ldquo;ring&rdquo; like riak<sup id=fnref1:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>, you loop back around and can pass even fewer messages/duplicates but risk greater latency.</p><h2 id=4-grow-only-counter>4. Grow-Only Counter</h2><p>Next up is strong eventual consistency with Conflict Free Replicated Data Types! <sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup> These allow us to replicate some data say a <code>count</code> of an integer <code>i32</code> across nodes by being <strong>available and partition tolerant</strong> guaranteeing that at some unknown point in the future, it converges to the same state for every participant, given certain properties are pure, in the functional programming sense ie &ndash; lack side effects like say &ldquo;addition&rdquo; of integers and the order in which this operation(s) is carried out doesn&rsquo;t affect the total result, also known as &ndash; commutativity:</p><pre tabindex=0><code>  +1
(node a)  (node b) (node C)
</code></pre><p>an increment on a is replicated to b and c <em>eventually</em> as:</p><pre tabindex=0><code>a few moments later...
  +1        +1       +1
(node a)  (node b) (node C)
</code></pre><p>and can as well happen as:</p><pre tabindex=0><code>  +2                +1
(node a) (node b) (node C)
</code></pre><p>we guarantee somehow, regardless of each addition operation occurs at some time <code>T_1</code>, even if another addition occurs concurrently at <code>T_2</code>,
because it&rsquo;s <em>commutative</em> , there&rsquo;s no contradiction that affects the final result when the network partition eventually heals, nor is co-ordination necessary.</p><pre tabindex=0><code>eventually consistent ヽ(‘ー`)ノ
  +2       +2        +2
(node a) (node b) (node C)
Total count = 6
</code></pre><p>We&rsquo;re given a <a href=https://jepsen.io/consistency/models/sequential>sequentially consistent</a> key-value store service and can use this to keep track of the current count on each node, each increment is called a <code>delta</code>, this <strong>greatly</strong> simplifies the problem:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>400</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>delta</span> <span class=o>:=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>body</span><span class=p>[</span><span class=s>&#34;delta&#34;</span><span class=p>].(</span><span class=kt>float64</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>previous</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>kv</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprint</span><span class=p>(</span><span class=s>&#34;counter-&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>ID</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>result</span> <span class=p>=</span> <span class=nx>delta</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>result</span> <span class=p>=</span> <span class=nx>previous</span><span class=p>.(</span><span class=kt>int</span><span class=p>)</span> <span class=o>+</span> <span class=nx>delta</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>kv</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprint</span><span class=p>(</span><span class=s>&#34;counter-&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>ID</span><span class=p>()),</span> <span class=nx>previous</span><span class=p>,</span> <span class=nx>result</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span></code></pre></div><p>and to return the current total count:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>NodeIDs</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=nx>count</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>kv</span><span class=p>.</span><span class=nf>ReadInt</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprint</span><span class=p>(</span><span class=s>&#34;counter-&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	  <span class=nx>result</span> <span class=p>=</span> <span class=nx>result</span> <span class=o>+</span> <span class=nx>count</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>However, say that we don&rsquo;t have a magical <code>SeqCst</code> store somewhere to pull out of our pocket for co-ordination of state, there are two approaches in theory:</p><ul><li>operation transform</li><li>state transform</li></ul><p>Roughly, sharing only the &ldquo;delta&rdquo; or current update ie <code>add 1</code> to the current global count is indicative of an <strong>operation-based design</strong> contrasted with sharing the entire the count state a <strong>state-based design</strong><sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>, for an integer this difference might seem trivial but it has deeper implications for more complex data structures, one of the big seeming disadvantages of an operation based representation is it requires <strong>a reliable broadcast</strong> with idempotence/de-duplication, retry ordering and &ldquo;reasonable&rdquo; time delivery semantics, which means if you&rsquo;re unlucky&mldr; state could diverge permanently, while the state based representation can tolerate partitions slightly more gracefully but requires more data over the wire which <strong>monotonically increases</strong>, which later gets &ldquo;merged&rdquo; and makes deletion more complex.</p><p>In summary, as long you can guarantee certain properties(associativity, commutativity, idempotence) it&rsquo;s possibly to resolve conflicts between replicas given certain constraints. All we need is an extra &ldquo;replicate&rdquo; handler which leverages the previous broadcast from before to <a href=https://github.com/hailelagi/gossip-glomers/blob/main/maelstrom-g-counter/operation_crdt.go>propagate the delta &lsquo;operationally&rsquo;</a> which often converges correctly but sometimes doesn&rsquo;t? maybe I&rsquo;m doing it wrong idk.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>session</span><span class=p>)</span> <span class=nf>replicateHandler</span><span class=p>(</span><span class=nx>msg</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>body</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>delta</span> <span class=o>:=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>body</span><span class=p>[</span><span class=s>&#34;delta&#34;</span><span class=p>].(</span><span class=kt>float64</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>localCount</span> <span class=o>+=</span> <span class=nx>delta</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>{</span><span class=s>&#34;type&#34;</span><span class=p>:</span> <span class=s>&#34;replicate_ok&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Other varieties exist like <code>PN Counters</code> which support subtraction/decrements, the G-Set &ndash; a set and <a href=https://crdt.tech/papers.html>much richer primitives</a> which includes <a href=https://madebyevan.com/algos/crdt-mutable-tree-hierarchy/>tree models that mirror the DOM</a> and sharing <a href=https://electric-sql.com/blog/2022/05/03/introducing-rich-crdts>JSON!</a> but that&rsquo;s enough for now. Libraries that abstract this away and allow you build super cool collaborative multiplayer stuff like google docs and <a href=https://www.figma.com/blog/how-figmas-multiplayer-technology-works/>figma</a> are: <a href=https://docs.yjs.dev/yjs-in-the-wild>YJS</a> or <a href=https://automerge.org/>automerge</a> and elixir/phoenix&rsquo;s very own <a href=https://hexdocs.pm/phoenix/Phoenix.Presence.html>Presence</a> on the server side which implements the <a href=https://hexdocs.pm/phoenix_pubsub/2.1.3/Phoenix.Tracker.html>Phoenix.Tracker</a> integrated with websockets and async processes so you can just build stuff, much wow! Ever wondered how discord&rsquo;s &ldquo;online&rdquo; feature works? it&rsquo;s CRDTs all the way down, you can <a href=https://hexdocs.pm/phoenix/Phoenix.Presence.html#module-fetching-presence-information>trivially experiment with implementing this in phoenix!</a></p><h2 id=5-kafka-style-log>5. Kafka-Style Log</h2><blockquote><p>As Gregor Samsa awoke one morning from uneasy dreams he found himself transformed in his bed into a gigantic insect.</p></blockquote><p>It&rsquo;s a bird, it&rsquo;s a plane&mldr; it&rsquo;s tiny kafka! No, not <em><a href=https://en.wikipedia.org/wiki/Franz_Kafka>that kafka</a></em>.
This one&rsquo;s what people use as a message bus, or broker, or messsage queue or event stream, <a href=https://microservices.io/patterns/data/event-sourcing.html>event sourcing</a> all the words, as it turns out stream processing is a big deal and super important infra<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup></p><blockquote><p>Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.</p></blockquote><p>In a nutshell this is a <a href=https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem>multi-producer, multi-consumer problem</a>, a <a href=https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf>classic computer science/OS concurency problem</a> aka the &ldquo;bounded buffer&rdquo; problem, with <em>a twist</em>.</p><p>You have &lsquo;producer&rsquo; or writer threads, and &lsquo;consumer&rsquo; threads which process or transform the written data, how to connect the two? &ndash; a shared buffer or &lsquo;channel&rsquo; that both threads can access and synchronize r/w access to.</p><p>go&rsquo;s channel abstraction solves a subset of this generalised problem, yet, here as hinted we have key differences in assumptions:</p><ol><li>when you read from a channel, this &ldquo;event&rdquo; is dequeued or destroyed.</li><li>It&rsquo;s <strong>guaranteed</strong> this destructive r/w will happen or it won&rsquo;t, <strong>exactly once</strong>.</li><li>There&rsquo;s effectively a <strong>reliable link</strong> between the producing go routine and the consuming go routine, it&rsquo;s just a pointer hop away.</li><li>goroutines may panic or fail and be observed to do so immediately, transparently and consistently according to the <a href=https://go.dev/ref/mem>runtime memory model</a></li><li>Everything happens in main-memory</li></ol><p>Each of these assumptions can be sent to <code>dev/null</code>:</p><ul><li>the network is unreliable</li><li>failure is everywhere</li><li>latency might as well be failure</li><li>concurrency is weird - duplicates, re-appearing, disappearing.</li><li>time is a lie</li></ul><p>Except the first, this “event” is dequeued or destroyed:</p><p>In the <a href=https://www.rabbitmq.com/docs/classic-queues>classic</a> publisher/subscriber model of protocols like <a href=https://www.rabbitmq.com/tutorials/amqp-concepts>AMQP</a>, a publisher &ldquo;pushes&rdquo; messages <a href=https://www.rabbitmq.com/docs/channels#basics>over the wire</a> via a router known as an exchange to the broker which has an <a href=https://github.com/rabbitmq/rabbitmq-server/blob/main/deps/rabbit/src/rabbit_classic_queue_index_v2.erl>index queue</a> and persistent/on-disk <a href=https://github.com/rabbitmq/rabbitmq-server/blob/main/deps/rabbit/src/rabbit_classic_queue_store_v2.erl#L10>store queue</a> (durably or transiently) which in turn <a href=https://www.rabbitmq.com/docs/consumers#subscribing>actively fowards</a> the message to the consumer until it ACKs this message then it is typically destroyed/removed <sup id=fnref:12><a href=#fn:12 class=footnote-ref role=doc-noteref>12</a></sup>.</p><blockquote><p>The persistent data structure used in messaging systems are often a per-consumer queue with an associated BTree or other general-purpose random access data structures to maintain metadata about messages.</p></blockquote><ul><li><a href=https://kafka.apache.org/documentation/#design_constanttime>https://kafka.apache.org/documentation/#design_constanttime</a></li></ul><pre tabindex=0><code>Producer                |                |  broker --&gt; |  consumer
Producer -&gt; &#39;push&#39;      | &lt;- exchange -&gt; |  queue  --&gt; |  consumer
Producer   to exchange  |                |  queue  --&gt; |  consumer
</code></pre><p>However Kafka is a <em><strong>log based</strong> message broker</em> not a queue.</p><p>What&rsquo;s the difference?</p><p>This <a href=https://kafka.apache.org/documentation/>nice diagram from the docs</a> gives an overview at a high level:</p><p><img src=https://kafka.apache.org/images/streams-and-tables-p1_p4.png alt="streams and tables"></p><p>In between producers and consumers is a broker, inside said &ldquo;broker&rdquo; server, we have the concept of &ldquo;topics&rdquo; basically <strong>a set of bounded buffers</strong> and partitions in the image: (P1, P2, P3, P4) &ndash; in the spirit of divide and conquer we split up the big problem into little one&rsquo;s, so we can process those individually &ndash; horizontally, in parallel.</p><pre tabindex=0><code>Producer -&gt;            |                           |  &lt;- consumer
Producer -&gt; &#39;push&#39;     | &#39;topics&#39; are partitioned  | &#39;pull&#39; consumer(s)
Producer -&gt; to topic   |   via some mechanism      |  &lt;- consumer
</code></pre><p>However there&rsquo;s a big problem &ndash; this is a distributed system, how do these &ldquo;bounded buffers&rdquo; share the same view?</p><blockquote><p>we need to ensure that every replica of the log <strong>eventually</strong> contains the
same entries in <strong>the same order</strong> even when some servers <strong>fail</strong> <sup id=fnref:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup></p></blockquote><p>We&rsquo;re interested in one neat thing &ndash; it provides a <em>durable replicated log<sup id=fnref:14><a href=#fn:14 class=footnote-ref role=doc-noteref>14</a></sup> <sup id=fnref:15><a href=#fn:15 class=footnote-ref role=doc-noteref>15</a></sup> <sup id=fnref:16><a href=#fn:16 class=footnote-ref role=doc-noteref>16</a></sup>.</em> There&rsquo;s a common aphorism in database rhetoric, &ldquo;the log is the database&rdquo; - is that true? idk but replicated logs are very useful in distributed systems and databases.<sup id=fnref:17><a href=#fn:17 class=footnote-ref role=doc-noteref>17</a></sup></p><blockquote><p>At its heart a Kafka partition is a replicated log. The replicated log is one of the most basic primitives in distributed data systems, and there are many approaches for implementing one.</p></blockquote><ul><li><a href=https://kafka.apache.org/documentation/#design_replicatedlog>https://kafka.apache.org/documentation/#design_replicatedlog</a></li></ul><p>The log is a totally ordered, immutable grow only sequence of &ldquo;events&rdquo; <sup id=fnref:18><a href=#fn:18 class=footnote-ref role=doc-noteref>18</a></sup>, sound familiar? this suspiciously sounds like a WAL &ndash; and infact it is! Kafka <a href=https://www.confluent.io/blog/transactions-apache-kafka/>even has transactions??!</a> but more on that later.</p><blockquote><p>Kafka organizes messages as a partitioned write-ahead commit log
on persistent storage and provides a pull-based messaging
abstraction to allow both real-time subscribers such as online services and offline subscribers such as Hadoop and data
warehouse to read these messages at arbitrary pace. <sup id=fnref1:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup></p></blockquote><p>Hopefully this explains <em>why</em> a replicated log<sup id=fnref2:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup> <sup id=fnref1:17><a href=#fn:17 class=footnote-ref role=doc-noteref>17</a></sup>, partitions need to have a consistently ordered view, yet how exactly does a log give us these properties? some observations:</p><ol><li>a position/offset is a &ldquo;timestamp&rdquo; independent of a system clock</li><li>reading state from this position is a <strong>deterministic</strong> process</li><li>write is simply an atomic <code>append</code>, to a cell that is &ldquo;filled&rdquo; or &ldquo;not&rdquo;.</li><li>an offset is <strong>monotonically increasing</strong> &ndash; fun with binary search!</li></ol><pre tabindex=0><code>(so many synonmyns!)
entry/tuple/event/message: {key, value, offset}
[{k1, hi, 0}, {k2, hello, 1}, {k2, world, 2}, {k1, foo, 3}, {k3, baz, 4}}]
</code></pre><p>Notice that keys can appear more than once and the latest entry for a key is its &ldquo;current&rdquo; value, each offset denotes a version of this event.</p><p>To replicate this log, two general approaches are considered <sup id=fnref3:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup> <sup id=fnref:19><a href=#fn:19 class=footnote-ref role=doc-noteref>19</a></sup>:</p><ol><li>primary-backup replication</li><li>and quorum-based replication</li></ol><p>In a primary-backup setup, we elect and maintain a leader which is responsible for the total order and strong consistency:</p><blockquote><p>A primary therefore assigns continuous and monotonically increasing serial
numbers to updates and instructs all secondaries to process
requests continuously in this order.</p></blockquote><p>Kafka has historically shippped quorums via a zookeeper/ZAB layer, but has recently provided <a href=https://developer.confluent.io/learn/kraft/>raft as an alternative</a>. Note how the abstractions are layered:</p><blockquote><p>We rely on the quorum-based Apache Zookeeper service for making
consensus decisions such as leader election and storing critical partition metadata such as replica lists, while using a
primary-backup approach for replicating logs from leader to
followers. The log format is much simpler with such separation since it does not need to maintain any leader election
related information, and the replication factor for the log
is decoupled from the number of parties required for the
quorum to proceed</p></blockquote><p>Which apparently raises interesting questions for operability, durability and delivery semantics folks seem to have strong debates and opinions on. There&rsquo;s a common association between the WAL and durability, but this is not necessarily true.
In this context, the WAL supports a pattern known as <a href=https://en.wikipedia.org/wiki/Change_data_capture>change data capture</a>.</p><blockquote><p>All data is immediately written to a persistent log on the filesystem without necessarily flushing to disk. In effect this just means that it is transferred into the kernel&rsquo;s pagecache.</p></blockquote><ul><li><a href=https://kafka.apache.org/documentation/#design_filesystem>https://kafka.apache.org/documentation/#design_filesystem</a></li></ul><p>Competitors like redpanda <a href=https://docs.redpanda.com/current/get-started/architecture/#raft-consensus-algorithm>ship raft</a> while warpstream does interesting things with <a href=https://www.warpstream.com/blog/minimizing-s3-api-costs-with-distributed-mmap>distributed mmap</a> and stateless agents, a different can of worms.</p><p>The challenge is thankfully much simpler &ndash; than having to implement distributed mmap or pulling in something like zookeeper or raft, we have yet again a magical convenient linearizable key value store, damn that&rsquo;s a nice primitive to have lying around. Why?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>node</span> <span class=o>:=</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nf>NewNode</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>kv</span> <span class=o>:=</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nf>NewLinKV</span><span class=p>(</span><span class=nx>node</span><span class=p>)</span>
</span></span></code></pre></div><p>A <code>lin-kv</code> is ideally all you need, wheter it&rsquo;s powered by raft or the <a href=https://en.wikipedia.org/wiki/Ra>sun god Ra</a>, we&rsquo;ve solved the difficult distributed systems problems of <strong>ordering</strong> and <strong>agreement</strong> across replicas when the leader dies, in the face of network partitions or concurrent servers which accept writes &ndash; one source of truth.</p><blockquote><p>Kafka dynamically maintains a set of in-sync replicas (ISR) that are caught-up to the leader. Only members of this set are eligible for election as leader. A write to a Kafka partition is not considered committed until all in-sync replicas have received the write</p></blockquote><p>In this much more simplistic model:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>replicatedLog</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>committed</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>float64</span>
</span></span><span class=line><span class=cl>	<span class=nx>version</span>   <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span>       <span class=p>[]</span><span class=nx>entry</span>
</span></span><span class=line><span class=cl>	<span class=nx>global</span>    <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>entry</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>key</span>    <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>value</span>  <span class=kt>float64</span>
</span></span><span class=line><span class=cl>	<span class=nx>offset</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>a producer needs to send an &ldquo;event&rdquo; or message to be appended, this is an <em>active replication</em> of the state machine:</li></ul><blockquote><p>Using FIFO-total order broadcast it is easy to build a replicated system: we broadcast every update request to the replicas, which update their state based on each message as it is delivered. This is called state machine replication (SMR)</p></blockquote><ul><li><a href=https://www.cl.cam.ac.uk/teaching/2122/ConcDisSys/dist-sys-notes.pdf>https://www.cl.cam.ac.uk/teaching/2122/ConcDisSys/dist-sys-notes.pdf</a></li></ul><blockquote><p>when using state machine replication, a replica that wants to update its state cannot do so immediately, but it has to go through the broadcast process, coordinate with other nodes, and wait for the update to be delivered back to itself.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// MUST BE: Linearizable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>session</span><span class=p>)</span> <span class=nf>sendHandler</span><span class=p>(</span><span class=nx>msg</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>body</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>retries</span> <span class=kd>chan</span> <span class=nx>retry</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// reserve a monotonic count slot
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>offset</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>log</span><span class=p>.</span><span class=nf>acquireLease</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>kv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>dest</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>NodeIDs</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>dest</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>400</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>replicaBody</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=s>&#34;type&#34;</span><span class=p>:</span> <span class=s>&#34;replicate&#34;</span><span class=p>,</span> <span class=s>&#34;offset&#34;</span><span class=p>:</span> <span class=nx>offset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=s>&#34;key&#34;</span><span class=p>:</span> <span class=nx>body</span><span class=p>[</span><span class=s>&#34;key&#34;</span><span class=p>],</span> <span class=s>&#34;msg&#34;</span><span class=p>:</span> <span class=nx>body</span><span class=p>[</span><span class=s>&#34;msg&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>SyncRPC</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>dest</span><span class=p>,</span> <span class=nx>replicaBody</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>retries</span> <span class=o>&lt;-</span> <span class=nx>retry</span><span class=p>{</span><span class=nx>body</span><span class=p>:</span> <span class=nx>replicaBody</span><span class=p>,</span> <span class=nx>dest</span><span class=p>:</span> <span class=nx>dest</span><span class=p>,</span> <span class=nx>attempt</span><span class=p>:</span> <span class=mi>20</span><span class=p>,</span> <span class=nx>err</span><span class=p>:</span> <span class=nx>err</span><span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>dest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>rebroadcast</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>retries</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// we must ensure this write broadcast is atomic and replicated to a quorum
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// for real kafka this is the ISR quorum, for me, this is 2/2 eazy peazy
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>retries</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;non-atomic broadcast&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>{</span><span class=s>&#34;type&#34;</span><span class=p>:</span> <span class=s>&#34;send_ok&#34;</span><span class=p>,</span> <span class=s>&#34;offset&#34;</span><span class=p>:</span> <span class=nx>offset</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>a consumer can ask or poll for new events:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>replicatedLog</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>offsets</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][][]</span><span class=kt>float64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>global</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>l</span><span class=p>.</span><span class=nx>global</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>result</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][][]</span><span class=kt>float64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>offset</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>offsets</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	        <span class=c1>// we can binary search the log!
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// or partition and route our search
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// and do all sorts of fun caching :)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>result</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>l</span><span class=p>.</span><span class=nf>seek</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>offset</span><span class=p>.(</span><span class=kt>float64</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>a client can synchronise processed offsets with the server(s):</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>replicatedLog</span><span class=p>)</span> <span class=nf>Commit</span><span class=p>(</span><span class=nx>kv</span> <span class=o>*</span><span class=nx>maelstrom</span><span class=p>.</span><span class=nx>KV</span><span class=p>,</span> <span class=nx>offsets</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>global</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>l</span><span class=p>.</span><span class=nx>global</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>offset</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>offsets</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>l</span><span class=p>.</span><span class=nx>committed</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>offset</span><span class=p>.(</span><span class=kt>float64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>a client can read from the latest committed offset:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>replicatedLog</span><span class=p>)</span> <span class=nf>ListCommitted</span><span class=p>(</span><span class=nx>keys</span> <span class=p>[]</span><span class=nx>any</span><span class=p>)</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>global</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>l</span><span class=p>.</span><span class=nx>global</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>offsets</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>key</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>keys</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>key</span> <span class=o>:=</span> <span class=nx>key</span><span class=p>.(</span><span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>offsets</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>committed</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>offsets</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Because this is a toy, the log grows forever, that&rsquo;s not okay &ndash; compaction is <a href=https://kafka.apache.org/documentation/#design_compactionbasics>it&rsquo;s own can of worms</a>. The log is also not persisted, which it would have to be in a real implementation as these datasets are typically large record batches that do zero-copy from network to disk, it&rsquo;s also inefficient, ideally we&rsquo;d want to actually partition the log for availability. However I&rsquo;m satisfied with the <a href=https://github.com/hailelagi/gossip-glomers/tree/main/maelstrom-kafka>overall solution</a>.</p><pre tabindex=0><code> :availability {:valid? true, :ok-fraction 0.99947566},
 :net {:all {:send-count 91240,
             :recv-count 91240,
             :msg-count 91240,
             :msgs-per-op 5.980206},
       :clients {:send-count 37488,
                 :recv-count 37488,
                 :msg-count 37488},
       :servers {:send-count 53752,
                 :recv-count 53752,
                 :msg-count 53752,
                 :msgs-per-op 3.5231042},
       :valid? true},
 :workload {:valid? true,
            :worst-realtime-lag {:time 0.261327208,
                                 :process 4,
                                 :key &#34;9&#34;,
                                 :lag 0.0},
            :bad-error-types (),
            :error-types (),
            :info-txn-causes ()},
 :valid? true}
</code></pre><p>All anyone has to do to build on this knowledge and make actual real life kafka is <a href=https://kafka.apache.org/documentation/#implementation>build literally everything else for the rest of your life</a>.</p><p><img src=/unfinished_horse.png alt="unfinished horse"></p><h2 id=6-totally-available-transactions>6. Totally-Available Transactions</h2><p>Finally, a distributed key-value store with transactions, or rather something simpler resembling the real thing.
I promised we would revist transactions, why and how kafka offers these semantics and demystifying transactions in general, here we are!</p><p>Transactions are a deep topic but first ACID, we&rsquo;re interested in specifically the &lsquo;C&rsquo; in there first - consistency. Before a bunch of theory what&rsquo;s our goal here?</p><ul><li>weak consistency (here be dragons!)</li><li>total availability (in CAP terms - AP)</li></ul><p>We&rsquo;ll revisit why these semantics matter. Let&rsquo;s focus on understanding the <strong>requirements</strong> as we go,
we need to define a handler that takes a single message/data structure with list of <code>operations</code> that look like:</p><p><code>[["r", 1, null], ["w", 1, 6], ["w", 2, 9]]</code>.</p><p>which means our handler needs to:</p><ul><li>read from kv[1]</li><li>write to kv[1]=6</li><li>write to kv[2]=9</li></ul><p>we can re-use the <code>store</code> from earlier as a key-value store:</p><pre tabindex=0><code>type store struct {
	index map[int]int
	log   []float64
}
</code></pre><p>all there is to figure out is the parsing for the above semantics:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>txn</span> <span class=o>:=</span> <span class=nx>body</span><span class=p>[</span><span class=s>&#34;txn&#34;</span><span class=p>].([]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>result</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([][]</span><span class=nx>any</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>op</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>txn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>op</span> <span class=o>:=</span> <span class=nx>op</span><span class=p>.([]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>op</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s>&#34;r&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>index</span> <span class=o>:=</span> <span class=nx>op</span><span class=p>[</span><span class=mi>1</span><span class=p>].(</span><span class=kt>float64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=p>[]</span><span class=nx>any</span><span class=p>{</span><span class=s>&#34;r&#34;</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=nx>index</span><span class=p>)]})</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>op</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s>&#34;w&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>index</span> <span class=o>:=</span> <span class=nx>op</span><span class=p>[</span><span class=mi>1</span><span class=p>].(</span><span class=kt>float64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>value</span> <span class=o>:=</span> <span class=nx>op</span><span class=p>[</span><span class=mi>2</span><span class=p>].(</span><span class=kt>float64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>kv</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=nx>index</span><span class=p>)]</span> <span class=p>=</span> <span class=nx>value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=p>[]</span><span class=nx>any</span><span class=p>{</span><span class=s>&#34;w&#34;</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=nx>index</span><span class=p>)]})</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>we try out empirically our first consistency model <code>read uncommitted</code>, huh &ndash; that was easy? what&rsquo;s all the fuss about these SQL anomalies and stuff? dirty writes? phantom skews? <sup id=fnref:20><a href=#fn:20 class=footnote-ref role=doc-noteref>20</a></sup></p><blockquote><p>Read uncommitted is a consistency model which prohibits dirty writes, where two transactions modify the same object concurrently before committing. In the ANSI SQL specification, read uncommitted is presumed to be the default</p></blockquote><p>but of course there&rsquo;s no free lunch, not really.</p><blockquote><p>The ANSI SQL 1999 spec places essentially no constraints on the behavior of read uncommitted. Any and all weird behavior is fair game.</p></blockquote><ul><li><a href=https://jepsen.io/consistency/models/read-uncommitted>https://jepsen.io/consistency/models/read-uncommitted</a></li></ul><p>All we need to do to prevent dirty writes is a <code>sync.RWMutex</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>kv</span><span class=p>.</span><span class=nx>global</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>global</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span></code></pre></div><p>There are &ldquo;bugs&rdquo; here, just depends on what the agreed upon definition is <sup id=fnref:21><a href=#fn:21 class=footnote-ref role=doc-noteref>21</a></sup> &ndash; what it boils down to, is what isolation and consistency models are really about. What are <strong>the semantics and rules can we agree on</strong> what is desired behaviour? is it fast? We&rsquo;ll get to that, next we need to replicate these transactions to every other node &ndash; all we have to prevent for now is the <a href=https://en.wikipedia.org/wiki/Write%E2%80%93write_conflict>write-write conflict</a>.</p><blockquote><p>Read uncommitted can be totally available: in the presence of network partitions, every node can make progress.</p></blockquote><p>Friendly reminder in CAP terms, this is AP - <em><strong>not</strong> consistent</em>.</p><blockquote><p>Moreover, read uncommitted does not require a per-process order between transactions. A process can observe a write, then fail to observe that same write in a subsequent transaction. In fact, a process can fail to observe its own prior writes, if those writes occurred in different transactions.</p></blockquote><p>interesting isn&rsquo;t it? Which is to say <strong>without replicating the data</strong> how would you really know the difference?</p><pre tabindex=0><code>go install . &amp;&amp; ../maelstrom/maelstrom test -w txn-rw-register \
--bin ~/go/bin/maelstrom-txn --node-count 2 --concurrency 2n \
--time-limit 20 --rate 1000 --consistency-models read-uncommitted \
--availability total --nemesis partition
</code></pre><p>lulls us into a false sense of security:</p><pre tabindex=0><code>Everything looks good! ヽ(‘ー`)ノ
</code></pre><p>but let&rsquo;s follow the <strong>requirements</strong> maybe this is going somewhere, we replicate it over the FIFO <code>broadcast protocol</code> from earlier, but don&rsquo;t gossip:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>session</span><span class=p>)</span> <span class=nf>replicateHandler</span><span class=p>(</span><span class=nx>msg</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>body</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>.</span><span class=nx>kv</span><span class=p>.</span><span class=nf>Commit</span><span class=p>(</span><span class=nx>body</span><span class=p>[</span><span class=s>&#34;txn&#34;</span><span class=p>].([]</span><span class=nx>any</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>{</span><span class=s>&#34;type&#34;</span><span class=p>:</span> <span class=s>&#34;replicate_ok&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><pre tabindex=0><code> :net {:all {:send-count 53194,
             :recv-count 53072,
             :msg-count 53194,
             :msgs-per-op 4.009497},
       :clients {:send-count 26538,
                 :recv-count 26538,
                 :msg-count 26538},
       :servers {:send-count 26656,
                 :recv-count 26534,
                 :msg-count 26656,
                 :msgs-per-op 2.0091958},
       :valid? true},
 :workload {:valid? true, :anomaly-types (), :anomalies nil},
 :valid? true}


Everything looks good! ヽ(‘ー`)ノ
</code></pre><p>Lastly, a stronger, somewhat more useful guarantee <a href=https://jepsen.io/consistency/models/read-committed><code>read-committed</code></a>, read committed prevents a new class of anomalies: <em>dirty reads</em>.</p><pre tabindex=0><code> :workload {:valid? false,
            :anomaly-types (:G1b),
            :anomalies {:G1b ({:op #jepsen.history.Op{:index 18240,
</code></pre><p>Thankfully there&rsquo;s a hint about the anomalies checked:</p><p><strong>G1a (aborted read)</strong>: An aborted transaction T1 writes key x,
and a committed transaction T2 reads that write to x.</p><p><strong>G1b (intermediate read)</strong>: A committed transaction T2 reads a
value of key x that was generated by transaction T1 other than T1’s final write of x.</p><p><strong>G1c (circular information flow)</strong>: A cycle of transactions linked by either
write-read or read-write dependencies. For instance, transaction T1
writes x = 1 and reads y = 2, and transaction T2 writes y = 2 and reads x = 1</p><p>In essence this means we must handle when <strong>transaction conflicts occur</strong>, specifically
we introduce/discover the concept of a <a href=https://en.wikipedia.org/wiki/Commit_(data_management)><code>commit</code></a>.
when do we offer commit comes down to <strong>what rules</strong> determine wheter a transaction aborts, and these give birth
to what we know as <strong>isolation levels</strong>.</p><p>This is a pernicious problem because isolation levels are often weakened to enable better concurrency/performance.
Throwing a <code>Mutex</code> on it and ensuring the data we replicate is what we commit else aborting is a simple solution that does work but it&rsquo;s boring. These are classifications that come up in multiversion concurrency/optimistic concurrency control and are relaxed constraints on ordering enable eeking out performance, you just can&rsquo;t get with a pessimistic lock, but this article is long enough :)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>retries</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span>
</span></span><span class=line><span class=cl>			<span class=nx>msg</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=s>&#34;type&#34;</span><span class=p>:</span> <span class=s>&#34;error&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=s>&#34;code&#34;</span><span class=p>:</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>TxnConflict</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=s>&#34;text&#34;</span><span class=p>:</span> <span class=s>&#34;txn abort&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=p>},</span>
</span></span><span class=line><span class=cl>		<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><pre tabindex=0><code> :workload {:valid? true,
            :anomaly-types (),
            :anomalies {},
            :not #{:cursor-stability :read-atomic},
            :also-not #{:ROLA
                        :causal-cerone
                        :consistent-view
                        :forward-consistent-view
                        :parallel-snapshot-isolation
                        :prefix
                        :repeatable-read
                        :serializable
                        :snapshot-isolation
                        :strong-serializable
                        :strong-session-serializable
                        :strong-session-snapshot-isolation
                        :strong-snapshot-isolation
                        :update-serializable}},
 :valid? true}
</code></pre><h2 id=7-testing-model-checkers-and-simulators>7. Testing, Model Checkers and Simulators</h2><p>If you&rsquo;ve been wondering, since these are just toy models, what&rsquo;s the delta between these simplified ideas and the real world?
They are obviously not intended for production and maelstrom is a teaching tool.</p><p>Where are the &ldquo;unit tests&rdquo;? If maelstrom/jepsen says so, does it make these implementations correct? maybe.</p><p>Intuitively, if you&rsquo;ve gotten this far, you should feel in your bones, distributed systems are different from single node ones.
The way we test them must change, because they require a fundamental shift in thinking to reason about and therefore verifying correctness of primitives. This is a hard problem with no easy answers. An overview of interesting things to explore in the space:</p><ul><li><a href=https://lamport.azurewebsites.net/tla/tla.html>TLA+</a></li><li><a href=https://martin.kleppmann.com/2014/11/25/hermitage-testing-the-i-in-acid.html>Hermitage</a></li><li>Deterministic simulation testing: ala <a href=https://apple.github.io/foundationdb/testing.html>foundationdb</a>, <a href=https://github.com/tigerbeetle/tigerbeetle/blob/main/src/vopr.zig>tigerbeetle&rsquo;s vopr</a>, <a href=https://antithesis.com/docs/introduction/how_antithesis_works.html>antithesis</a> and much more I probably haven&rsquo;t discovered.</li></ul><p>If that sounds like a pretty high bar for correctness <strong>it&rsquo;s because it is</strong>. Verifying the correctness of distributed systems/databases is a non-trivial problem, when building applications implictly there&rsquo;s trust that the claimed semantics are true, composing them properly is a different matter entirely. Maelstrom uses jepsen/elle<sup id=fnref:22><a href=#fn:22 class=footnote-ref role=doc-noteref>22</a></sup> the model checker which powers a fair bit of some the invariant checks, which is way over my head at this time.</p><blockquote><p>An ideal checker would be sound (no false positives), efficient (polynomial
in history length and concurrency), effective (finding violations in
real databases), general (analyzing many patterns of transactions),
and informative (justifying the presence of an anomaly with understandable counterexamples). Sadly, we are aware of no checkers
that satisfy these goals.</p></blockquote><p>Sounds a lot more rigorous than a unit test no?</p><p><img src=/good.png alt="Gyomei Himejima - Good for you for seeing it through"></p><p>and that&rsquo;s it! fun with distributed systems, scalability but <a href=https://www.usenix.org/system/files/conference/hotos15/hotos15-paper-mcsherry.pdf>at what COST?</a>, here&rsquo;s LMAX doing <a href=https://www.infoq.com/presentations/LMAX/>100k TPS in &lt; 1ms</a> in 2010 on a single thread of &ldquo;commodity hardware&rdquo;, <a href=https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/>distributed systems are a necessary evil requiring a different lens</a>.</p><div class=callout-warning>💡
If you enjoyed reading this please consider thoughtfully sharing it with someone who might find it interesting!</div><h3 id=references>References</h3><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://datatracker.ietf.org/doc/html/rfc4122#section-4.2.1>https://datatracker.ietf.org/doc/html/rfc4122#section-4.2.1</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://en.wikipedia.org/wiki/Snowflake_ID>https://en.wikipedia.org/wiki/Snowflake_ID</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=http://yellerapp.com/posts/2015-02-09-flake-ids.html>http://yellerapp.com/posts/2015-02-09-flake-ids.html</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://www.cockroachlabs.com/blog/living-without-atomic-clocks/>https://www.cockroachlabs.com/blog/living-without-atomic-clocks/</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://docs.riak.com/riak/kv/2.2.3/learn/concepts/clusters.1.html>https://docs.riak.com/riak/kv/2.2.3/learn/concepts/clusters.1.html</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf>https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://highscalability.com/gossip-protocol-explained/>https://highscalability.com/gossip-protocol-explained/</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p><a href=https://github.com/hashicorp/memberlist>https://github.com/hashicorp/memberlist</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p><a href=https://inria.hal.science/inria-00555588/document>https://inria.hal.science/inria-00555588/document</a>&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p><a href=https://www.cs.utexas.edu/~rossbach/cs380p/papers/Counters.html>https://www.cs.utexas.edu/~rossbach/cs380p/papers/Counters.html</a>&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p><a href=http://dist-prog-book.com/chapter/9/streaming.html>http://dist-prog-book.com/chapter/9/streaming.html</a>&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:12><p><a href=https://www.rabbitmq.com/docs/confirms#acknowledgement-modes>https://www.rabbitmq.com/docs/confirms#acknowledgement-modes</a>&#160;<a href=#fnref:12 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:13><p><a href=https://www.vldb.org/pvldb/vol8/p1654-wang.pdf>https://www.vldb.org/pvldb/vol8/p1654-wang.pdf</a>&#160;<a href=#fnref:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref3:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:14><p><a href=https://mesos.apache.org/documentation/latest/replicated-log-internals/>https://mesos.apache.org/documentation/latest/replicated-log-internals/</a>&#160;<a href=#fnref:14 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:15><p><a href=https://en.wikipedia.org/wiki/State_machine_replication>https://en.wikipedia.org/wiki/State_machine_replication</a>&#160;<a href=#fnref:15 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:16><p><a href=https://blog.x.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic>https://blog.x.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic</a>&#160;<a href=#fnref:16 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:17><p><a href=https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying>https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying</a>&#160;<a href=#fnref:17 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:17 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:18><p><a href=https://www.cs.cornell.edu/fbs/publications/ibmFault.sm.pdf>https://www.cs.cornell.edu/fbs/publications/ibmFault.sm.pdf</a>&#160;<a href=#fnref:18 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:19><p><a href=https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/tr-2008-25.pdf>https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/tr-2008-25.pdf</a>&#160;<a href=#fnref:19 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:20><p><a href=https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf>https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf</a>&#160;<a href=#fnref:20 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:21><p><a href=https://pmg.csail.mit.edu/papers/icde00.pdf>https://pmg.csail.mit.edu/papers/icde00.pdf</a>&#160;<a href=#fnref:21 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:22><p><a href=https://www.vldb.org/pvldb/vol14/p268-alvaro.pdf>https://www.vldb.org/pvldb/vol14/p268-alvaro.pdf</a>&#160;<a href=#fnref:22 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>Copyright © 2024 Haile Lagi</a><div><span>private inquiries: hailelagi[at]gmail.com</span></div><div><span>or informally(twitter/x): https://x.com/haile_lagi</span></div></footer></body></html>