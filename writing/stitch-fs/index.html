<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=‚Äùog:title‚Äù content="Stitching Together Filesystems | Haile (·àê·ã≠·àå)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Stitching Together Filesystems | Haile (·àê·ã≠·àå)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>Stitching Together Filesystems</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (·àê·ã≠·àå)</a></h2><nav><ul><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=notes>notes</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Stitching Together Filesystems</h1><time>December 6, 2024</time><meta name=twitter:card content="summary">
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><p>The modern computing/data infrastructure is <a href=https://landscape.cncf.io/>vast and interesting</a>. What happens when you read or write some data persistently?</p><p>What <em>really</em> lurks in the world of disk IO? what is at the core? how do abstractions like <a href=https://github.com/awslabs/mountpoint-s3>mountpoint-s3</a>, <a href=https://cloud.google.com/storage/docs/cloud-storage-fuse/overview>google&rsquo;s cloud-storage fuse</a> or <a href=https://docs.ceph.com/en/reef/man/8/ceph-fuse/>ceph-fuse</a> come to be filesystems?</p><p>Why a filesystem? It seems like <strong>a fundamental abstraction</strong>, an idea so pervasive to any computer, it&rsquo;s important to appreciate it&rsquo;s an <em>invention</em>. What do sophisticated filesystems old and new alike, say <strong>zfs</strong><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, <strong>xfs</strong><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, <strong>ffs</strong><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> and <a href=https://www.kernel.org/doc/html/v4.20/filesystems/ext4/index.html>ext4</a> really do? why are there so many? what are the <em>key ideas and design tradeoffs?</em> what are the <em>workloads?</em> Like all abstractions we begin not by looking at the implementation we look at the <em>interfaces</em>.</p><p>A quick glance at <a href=https://github.com/hailelagi/flubber>flubber a FUSE fs on object storage</a>:</p><script async id=asciicast-569727 src=https://asciinema.org/a/569727.js></script><h2 id=physical-layer>Physical Layer</h2><p>At the bottom, there must exist some <em>physical media</em> which will hold data we conveniently call a &lsquo;block&rsquo;. It could be an HDD, SSD, <a href=https://aws.amazon.com/storagegateway/vtl/>tape</a> or something else, <a href=https://pages.cs.wisc.edu/~remzi/OSTEP/file-devices.pdf>what interface does this physical media present?</a> It&rsquo;s exposed over many <em>protocols</em>.</p><p><img src=/sketch_fs.svg alt="simplified sketch of file system layering"></p><p class=subtext style=font-size:.8em;color:#666>An important theme here is the _compositional_ almost recursive nature of storage interfaces, this comes up again and again and again. :)</p><p>A hard disk drive exposes a &ldquo;flat&rdquo; address space to read or write, the smallest atomic unit is a sector (e.g 512-byte block) and flash based solid state drives expose a unit called a &ldquo;page&rdquo; to which we can issue read or write &ldquo;commands&rdquo; [‚Ä†1] above which are the intricacies of <a href=https://lwn.net/Kernel/LDD3/><em>drivers</em></a> (or if you&rsquo;re lucky EC2&rsquo;s generic NVMe interface or a protocol like NVMe express) and then many generic block interfaces, there are quite a few layers to experiment with, what we need is a block device abstraction, but which one? a few options:</p><ol><li><a href=https://linux-kernel-labs.github.io/refs/heads/master/labs/block_device_drivers.html#overview>the linux kernel block interface</a></li><li><a href=https://spdk.io/doc/ublk.html>ublk</a></li><li><a href=https://libvirt.org/storage.html>libvirt</a></li><li><a href=https://www.kernel.org/doc/html/v6.3/filesystems/fuse.html>fuse</a></li><li><a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>k8&rsquo;s container storage interface</a></li></ol><div class=callout-warning>üí°
All problems in computer science can be solved by another level of
indirection, except of course for the problem of too many indirections.</div><p>As it turns out a filesystem is historically an <em>internal</em> sub-component of the operating system! in kernel/priviledged space. However there&rsquo;s all these interesting <em>usecases</em> for writing all sorts of different <em>kinds of filesystems</em> which make different <em>design decisions</em> at different layers, wouldn&rsquo;t it be nice to not brick yourself mounting some random filesystem I made? How about an <em>EC2 instance</em>? or a <a href=https://docs.docker.com/engine/storage/>docker container?</a> today where workloads run above <a href=https://pages.cs.wisc.edu/~remzi/OSTEP/vmm-intro.pdf>hypervisors</a> how does that change the interface?</p><p>What is a filesystem <em>really?</em> to linux at least it&rsquo;s <a href=https://en.wikipedia.org/wiki/Everything_is_a_file>the universe and everything else</a>, in general it&rsquo;s a way of <strong>organising</strong> data and metadata for <strong>access.</strong></p><p>That&rsquo;s a very generic definition, that doesn&rsquo;t say much.</p><p>Filesystems are an incredibly versatile abstraction, applying to networked/distributed systems<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>, <a href=https://man7.org/linux/man-pages/man7/cgroups.7.html>process management</a>, <a href=https://docs.kernel.org/filesystems/tmpfs.html>memory management</a> and what one would normally assume it&rsquo;s for &ndash; persistent storage.</p><p>A simple (and useful) interpretation of a filesystem is an interface/sub-system that allows the management of blocks of data on disk, metadata and exposing the interface of <strong>files</strong> and <strong>directories.</strong> This system needs to be laid out on disk, which is not byte-addressable and therefore requires a bit of thinking about layout, a first approximation could be:</p><pre tabindex=0><code>++++++++++++++++++++++++++++++++++++++
+ superblock + inodes + data region  +
++++++++++++++++++++++++++++++++++++++
</code></pre><p>Some definitions:</p><ol><li><strong>file</strong></li></ol><p>Is really a <code>struct</code> called an index-node (inode) - managing information to find where this file&rsquo;s blocks are, it maps the human readable name to an internal pointer(i number), services an external handle/view(the file descriptor <code>fd</code>) - and so much more! perhaps laid as some kind of hashmap/table?</p><ol start=2><li>*<em>directory</em></li></ol><p>also an inode! the <code>.</code>, parent <code>..</code> path name <code>/foo</code> etc</p><ol start=3><li><strong>super block</strong></li></ol><p>A special kind of header stores interesting global metadata (inode count, fs version, etc) this is read by the operating system during <a href=https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/9/html/managing_file_systems/mounting-file-systems_managing-file-systems#the-linux-mount-mechanism_mounting-file-systems>mount</a></p><ol start=4><li><strong>data region</strong>: the actual data we care about storing!</li></ol><p>and access methods responding to the syscalls users care about for actually interacting with their data: open(), read(), write(), fstat() etc</p><p>Files and directories are really inodes which can map <code>hello.txt</code> in <code>user/hello</code>to some arbitrary block location(on disk) <code>0x88a...</code> dumped as hex pointed to by an <code>inumber</code> and finally to the sector region(assuming an HDD). For example to find the block for <code>hello.txt</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># assuming a unix(ish)</span>
</span></span><span class=line><span class=cl><span class=c1># to retrieve the pagesize</span>
</span></span><span class=line><span class=cl><span class=c1># assume the sector size is 512bytes and a block 4KiB</span>
</span></span><span class=line><span class=cl>getconf PAGESIZE
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## you can see an inode&#39;s inumber via:</span>
</span></span><span class=line><span class=cl>ls -i hello.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>block</span> <span class=o>=</span> <span class=o>(</span>inumber * sizeof<span class=o>(</span>inode_t<span class=o>))</span> / blockSize<span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>sector</span> <span class=o>=</span> <span class=o>((</span>block * blockSize<span class=o>)</span> + inodeStartAddr<span class=o>)</span> / sectorSize<span class=p>;</span>
</span></span></code></pre></div><p>To make this concrete, with some help from <code>xv6-riscv</code>, when the filesystem reads from disk given an <code>inumber</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>rinode</span><span class=p>(</span><span class=n>uint</span> <span class=n>inum</span><span class=p>,</span> <span class=k>struct</span> <span class=n>dinode</span> <span class=o>*</span><span class=n>ip</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>BSIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>bn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>dinode</span> <span class=o>*</span><span class=n>dip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>bn</span> <span class=o>=</span> <span class=nf>IBLOCK</span><span class=p>(</span><span class=n>inum</span><span class=p>,</span> <span class=n>sb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>rsect</span><span class=p>(</span><span class=n>bn</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>dip</span> <span class=o>=</span> <span class=p>((</span><span class=k>struct</span> <span class=n>dinode</span><span class=o>*</span><span class=p>)</span><span class=n>buf</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>inum</span> <span class=o>%</span> <span class=n>IPB</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>ip</span> <span class=o>=</span> <span class=o>*</span><span class=n>dip</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This glosses over considering how <code>ls -i</code> <em>finds</em> the inumber from <strong>disk</strong> in the first place: and presumes that our files
fit in a 4KiB chunk &ndash; examining <code>cutecat.gif</code> on any computer eludes to more going on.</p><p>In a nutshell, answering the first question requires traversing from the <em>root</em> <strong>on every single access to resolve hello.txt -> inum 2</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Look up and return the inode for a path name.
</span></span></span><span class=line><span class=cl><span class=c1>// If parent != 0, return the inode for the parent and copy the final
</span></span></span><span class=line><span class=cl><span class=c1>// path element into name, which must have room for DIRSIZ bytes.
</span></span></span><span class=line><span class=cl><span class=c1>// Must be called inside a transaction since it calls iput().
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=k>struct</span> <span class=n>inode</span><span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>namex</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nameiparent</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>ip</span><span class=p>,</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=o>*</span><span class=n>path</span> <span class=o>==</span> <span class=sc>&#39;/&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ip</span> <span class=o>=</span> <span class=nf>iget</span><span class=p>(</span><span class=n>ROOTDEV</span><span class=p>,</span> <span class=n>ROOTINO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=n>ip</span> <span class=o>=</span> <span class=nf>idup</span><span class=p>(</span><span class=nf>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>cwd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>((</span><span class=n>path</span> <span class=o>=</span> <span class=nf>skipelem</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>name</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>ilock</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>ip</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>!=</span> <span class=n>T_DIR</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=nf>iunlockput</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>nameiparent</span> <span class=o>&amp;&amp;</span> <span class=o>*</span><span class=n>path</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Stop one level early.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nf>iunlock</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>ip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>next</span> <span class=o>=</span> <span class=nf>dirlookup</span><span class=p>(</span><span class=n>ip</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=nf>iunlockput</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>iunlockput</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ip</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>nameiparent</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>iput</span><span class=p>(</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ip</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This <em>is</em> pretty expensive and there&rsquo;s more to be said about designing access methods and traversing inodes efficiently and their interaction with page tables. As a play on our re-occurent theme, to represent more space than a page size <strong>we introduce more indirection</strong> in the form of <em>pointers</em>, these pointers can come in the form of <em>extents</em> which are in essence conceptually a pointer + block len, or multi-level indexes which are &ldquo;stringed together&rdquo; pointers to a page with pointers highlighting a choice between flexibility vs a space compact representation.</p><h2 id=filesystems-are-composable>Filesystems are composable!</h2><p>Filesystems are an interface and one goal of a good interface is <em>composability</em>, no matter how many times I heard it or read about it didn&rsquo;t quite make sense. For example when I first mounted my fuse filesystem, I hadn&rsquo;t implemented directory path traversal, the link to it&rsquo;s parent filesystem was broken:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>haile@ubuntu:/Users/haile/documents/github$ <span class=nb>cd</span> flubber
</span></span><span class=line><span class=cl>-bash: cd: flubber: Transport endpoint is not connected
</span></span></code></pre></div><p>// todo fix this
A filesystem is software. It compiles down to a binary known as an image, to use this <em>image</em> we need to execute it through <code>mkfs</code> a fancy way of registering it with the operating system and <code>mount</code> it - producing a visible interface to interact with it via &ndash; yet another filesystem?</p><p>// todo better explain mounts and binds</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>haile@ubuntu:/Users/haile$ mount <span class=p>|</span> grep flubber
</span></span><span class=line><span class=cl>rawBridge on /temp/flubber-fuse <span class=nb>type</span> fuse.rawBridge <span class=o>(</span>rw,nosuid,nodev,relatime,user_id<span class=o>=</span>0,group_id<span class=o>=</span>0,max_read<span class=o>=</span>131072<span class=o>)</span>
</span></span><span class=line><span class=cl>rawBridge on /Users/haile/documents/github/flubber <span class=nb>type</span> fuse.rawBridge <span class=o>(</span>rw,nosuid,nodev,relatime,user_id<span class=o>=</span>501,group_id<span class=o>=</span>501,max_read<span class=o>=</span>131072<span class=o>)</span>
</span></span></code></pre></div><p>As it turns out this is a somewhat reasonable thing to do and is known as a recursive mount or here&rsquo;s an abridged example <a href=https://github.com/hanwen/go-fuse/blob/master/example/loopback/main.go>from the go-fuse documentation</a> of a loopback filesystem which implements a recursive mount using an fs layer below it as storage:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>loopbackRoot</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fs</span><span class=p>.</span><span class=nf>NewLoopbackRoot</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>server</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fs</span><span class=p>.</span><span class=nf>Mount</span><span class=p>(</span><span class=s>&#34;/mnt&#34;</span><span class=p>,</span> <span class=nx>loopbackRoot</span><span class=p>,</span> <span class=nx>opts</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Signal</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>signal</span><span class=p>.</span><span class=nf>Notify</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Interrupt</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>SIGTERM</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>&lt;-</span><span class=nx>c</span>
</span></span><span class=line><span class=cl>		<span class=nx>server</span><span class=p>.</span><span class=nf>Unmount</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>server</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}:</span>
</span></span></code></pre></div><p>At every point during the boot &lt;> runtime lifecycle of an operating system(linux at least) there probably exist filesystems which mount themselves on themselves at some <strong>mount point</strong>, as par for course this implies a <a href=https://systemd.io/MOUNT_REQUIREMENTS/>root fs</a>. This compositional nature is often exploited by CoW filesystems to cache or recreate filesystem objects, by interacting with the FUSE kernel api, you can mount anything you&rsquo;d like right in userspace! &ndash; more important than <em>how</em> is <em>why.</em></p><h2 id=why-fuse>why fuse?</h2><p>Hopefully it makes sense that file system heirarchies can be built as an interface over whatever you like &ndash; with FUSE or <code>ublk</code> it&rsquo;s right in userspace, no need to muck about the kernel, google drive, your <a href=https://github.com/lvkv/whenfs>calendar</a>, a zip archive, <a href=https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol>icmp packets</a>&mldr; it goes on, you are only bounded by imagination &ndash; but should you put it in production?<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> I don&rsquo;t know, but I know it&rsquo;s possible to do so over object storage and is a natural fit<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> for certain workloads such as machine learning and analytics: it&rsquo;s cheap, and POSIX access methods are well understood by existing applications, however <a href=https://materializedview.io/p/the-quest-for-a-distributed-posix-fs>beware of latency and compatibility.</a></p><div class=callout-warning>üí°
aside on POSIX, there are "popular" syscalls say open, read, write, close, lseek, mkdir etc
but how about the flock, fcntl and ioctl family? How would those work across a network boundary? what syscalls
do applications need?</div><h2 id=interacting-with-the-fuse-protocol>interacting with the fuse protocol</h2><p>There&rsquo;s an abstraction layer that wasn&rsquo;t mentioned in the first diagram - which sits just below the application in linux known as the <a href=https://docs.kernel.org/filesystems/vfs.html>linux virtual filesystem</a> which allows the dispatching of messages in the FUSE protocol somewhat similar to a client-server model:</p><pre tabindex=0><code>+++++++        +++++++++++         ++++++++++++
+ app +  &lt;--&gt;  + go-fuse + &lt;------&gt; +  daemon +
+++++++        ++++++++++          +++++++++++++
   |                               \ (exchange messages at `/dev/fuse`)
   |                                | (memcpy per msg)
------(user/kernel boundary)------
   |                               +++++++++++++++
+++++++                            ++ fuse kernel +
+ VFS + -------------------------&gt; ++  driver ++++
+++++++                            +++++++++++++++
</code></pre><blockquote><p>The High-level FUSE API builds on top of the lowlevel API and allows developers to skip the implementation of the path-to-inode mapping. Therefore, neither inodes nor lookup operations exist in the high-level API,
easing the code development. Instead, all high-level API
methods operate directly on file paths. The high-level
API also handles request interrupts and provides other
convenient features: e.g., developers can use the more
common chown(), chmod(), and truncate()
methods, instead of the lower-level setattr(). File
system developers must decide which API to use, by balancing flexibility vs. development ease.</p></blockquote><blockquote><p>If a user-space file system implements
the write buf() method, then FUSE splices the data
from /dev/fuse and passes the data directly to this
method in a form of the buffer containing a file descriptor. FUSE splices WRITE requests that contain more than
a single page of data. Similar logic applies to replies to
READ requests with more than two pages of data</p></blockquote><h2 id=write-back-caching>Write-back caching</h2><p>The basic write behavior of FUSE is synchronous and only 4KB of data is sent to the user daemon for writing.</p><h2 id=inodes-access-methods-concurrency--garbage-collection>Inodes, access methods, concurrency & garbage collection</h2><p>The command <code>ls -i hello.txt</code> helped us find the inode for our file, guided the discovery of file/directory name translation to an inode,
what more can it tell us? A key decision in the design and performance of filesystems is the inode representation, inodes can most commonly be represented by a bitmap, linked-list or a b-tree</p><p>todo a contrast with log structured filesystems.</p><p>todo RUM ref</p><h2 id=file-systems-come-with-great-responsibility>File systems come with great responsibility</h2><p>A semantic guarantee with a heavy burden that filesystems and tangentially databases make is to say they&rsquo;ll take your data to disk and won&rsquo;t lose it along the way via some kind of mechanisms to force writes to disk, in the face of the real world which can and does <em>lose</em> data<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> and sometimes lies about it, alas our software and hardware are trying their best and define models like &ldquo;crash stop&rdquo; and &ldquo;fail stop&rdquo;, this gets doubly hard for large data centers and distributed systems<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup> where data loss isn&rsquo;t just loss, it&rsquo;s a cascade failure mode of corruption and headaches. There are of course many things to be done to guard against the troubling world of physical disks, such as magic numbers, checksums and RAID which transparently map logical IO to physical IO for fault-tolerance in a fail-stop model via your preffered mapping (stripping, mirroring & parity.) and of course the <a href=https://transactional.blog/blog/2024-erasure-coding>clever rabbit hole of bit flipping repair algorithms</a>.</p><p>Perhaps a more disturbing thought, why a filesystem if you have a database?<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup> <a href=https://www.sqlite.org/fasterthanfs.html>SQLite</a> seems to agree, as does <a href=https://docs.oracle.com/cd/B16351_01/doc/server.102/b14196/asm001.htm#>Oracle</a>, it&rsquo;s certainly interesting and perhaps it&rsquo;s worth the inherited complexity? why stop at the filesystem? or disk manager? perhaps let&rsquo;s do away with the operating system altogether?<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup> questions for another time :)</p><div class=callout-warning>üí°
Security and access control in whatever form is an important consideration in filesystem design, especially in a distributed context where the network provides a wider surface area of attack than the process boundary. User groups and access control lists are often something to considering when implementing a filesystem abstraction.</div><h2 id=references--notes>References & Notes</h2><p>[‚Ä†1]: Although the smallest unit of a flash is actually a cell, and a write/erase may touch on the block, for simplicity and rough equivalence these are equated.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://research.cs.wisc.edu/wind/Publications/zfs-corruption-fast10.pdf>End-to-end Data Integrity for File Systems: A ZFS Case Study</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://users.soe.ucsc.edu/~sbrandt/290S/xfs.pdf>Scalability in the XFS File System</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://dsf.berkeley.edu/cs262/FFS-annotated.pdf>fast file system(FFS)</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://www.usenix.org/legacy/event/osdi06/tech/full_papers/weil/weil.pdf>Ceph: A Scalable, High-Performance Distributed File System</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf>Google File System</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://libfuse.github.io/doxygen/fast17-vangoor.pdf>To FUSE or Not to FUSE: Performance of User-Space File Systems</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://www.vldb.org/pvldb/vol16/p2769-durner.pdf>Exploiting Cloud Object Storage for High-Performance Analytics</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p><a href=https://www.usenix.org/system/files/atc20-rebello.pdf>Can Applications Recover from fsync Failures?</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p><a href=https://www.usenix.org/conference/fast18/presentation/alagappan>Protocol Aware Recovery</a>&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p><a href=https://www.cs.cit.tum.de/fileadmin/w00cfj/dis/papers/blob.pdf>Why Files If You Have a DBMS?</a>&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p><a href=https://www.vldb.org/pvldb/vol17/p2115-leis.pdf>Cloud-Native Database Systems and Unikernels: Reimagining OS Abstractions for Modern Hardware</a>&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>Copyright ¬© 2025 Haile Lagi</a><div><span>feel free to reach out: hailelagi[at]gmail.com</span></span></div></footer></body></html>