<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel="shortcut icon" href=https://www.hailelagi.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>The weight of choice is heavy</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href=/bookshelf title=bookshelf>bookshelf</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>The weight of choice is heavy</h1><time>August 31, 2020</time></header><p>What are the odds? I&rsquo;ve spent quite a few hours invested in implementing a seemingly innocent feature of a game I&rsquo;m
currently working on as part of my learning in the world of functional programming with Elixir. I won&rsquo;t bore you with
the details, I haven&rsquo;t even finished making the game, the prelude to discovering this problem is an innocent one.
It&rsquo;s a terminal dungeon crawling game, where you venture into dark rooms in search of treasure and an eventual (hopeful) exit.</p><p>The probability of choosing a room is controlled by a call to <code>Enum.random(iterable)</code> which selects a random element
from the iterable, using Erlang&rsquo;s internal pseudo-random generation algorithm. At this point in time, only three rooms
existed (a room leading to the exit, A room full of monsters and another room full of monsters.)
Therefore it&rsquo;s safe to <em>assume</em> the mathematical probability of finding any room is P(1/3). This isn&rsquo;t so great is it?
You could just start the game and one-third of the time, without experiencing even a single battle :(
Oh I know the author suggests&mldr; let&rsquo;s add different probabilities to the rooms, such that rooms with battles appear
more likely and rooms with an exit less likely. Okay&mldr; so I tried it, after the first hour or so I came up with a
satisfactory(to me I thought) solution. This is it. I first added a probability key, with a value of an array of atoms to the struct.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Elixir data-lang=Elixir><span class=line><span class=cl><span class=kd>defmodule</span> <span class=nc>DungeonCrawl.Room</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=na>@moduledoc</span> <span class=sh>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=sh>  data structure representing a &#34;room&#34;
</span></span></span><span class=line><span class=cl><span class=sh>  a room has &#34;actions&#34; borrowed
</span></span></span><span class=line><span class=cl><span class=sh>  &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>  <span class=kn>alias</span> <span class=nc>DungeonCrawl.Room</span><span class=p>,</span> <span class=ss>as</span><span class=p>:</span> <span class=nc>Room</span>
</span></span><span class=line><span class=cl>  <span class=kn>alias</span> <span class=nc>DungeonCrawl.Room.Triggers</span><span class=p>,</span> <span class=ss>as</span><span class=p>:</span> <span class=nc>Triggers</span>
</span></span><span class=line><span class=cl>  <span class=kn>import</span> <span class=nc>DungeonCrawl.Room.Action</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>defstruct</span> <span class=ss>name</span><span class=p>:</span> <span class=no>nil</span><span class=p>,</span> <span class=ss>description</span><span class=p>:</span> <span class=no>nil</span><span class=p>,</span> <span class=ss>actions</span><span class=p>:</span> <span class=p>[],</span> <span class=ss>trigger</span><span class=p>:</span> <span class=no>nil</span><span class=p>,</span> <span class=ss>probability</span><span class=p>:</span> <span class=no>nil</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>def</span> <span class=n>all</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=ss>do</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>      <span class=p>%</span><span class=nc>Room</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=ss>name</span><span class=p>:</span> <span class=ss>:exit</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=ss>description</span><span class=p>:</span> <span class=s2>&#34;You can see a small light from a crack in the walls&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=ss>actions</span><span class=p>:</span> <span class=p>[</span><span class=n>forward</span><span class=p>()],</span>
</span></span><span class=line><span class=cl>        <span class=ss>trigger</span><span class=p>:</span> <span class=nc>Triggers.Exit</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=ss>probability</span><span class=p>:</span> <span class=p>[</span><span class=ss>:exit</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>%</span><span class=nc>Room</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=ss>name</span><span class=p>:</span> <span class=ss>:goblin</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=ss>description</span><span class=p>:</span> <span class=s2>&#34;You can see an enemy blocking your path&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=ss>actions</span><span class=p>:</span> <span class=p>[</span><span class=n>forward</span><span class=p>()],</span>
</span></span><span class=line><span class=cl>        <span class=ss>trigger</span><span class=p>:</span> <span class=nc>Triggers.Enemy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=ss>probability</span><span class=p>:</span> <span class=p>[</span><span class=ss>:goblin</span><span class=p>,</span> <span class=ss>:goblin</span><span class=p>,</span> <span class=ss>:goblin</span><span class=p>,</span> <span class=ss>:goblin</span><span class=p>,</span> <span class=ss>:goblin</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>%</span><span class=nc>Room</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=ss>name</span><span class=p>:</span> <span class=ss>:ogre</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=ss>description</span><span class=p>:</span> <span class=s2>&#34;Something moves around in the dark, what do you do?&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=ss>actions</span><span class=p>:</span> <span class=p>[</span><span class=n>forward</span><span class=p>()],</span>
</span></span><span class=line><span class=cl>        <span class=ss>trigger</span><span class=p>:</span> <span class=nc>Triggers.Enemy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=ss>probability</span><span class=p>:</span> <span class=p>[</span><span class=ss>:ogre</span><span class=p>,</span> <span class=ss>:ogre</span><span class=p>,</span> <span class=ss>:ogre</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>At once you can probably see the naiveness of this solution. What computed the algorithm is this</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Elixir data-lang=Elixir><span class=line><span class=cl> <span class=kd>defp</span> <span class=n>bias_probability</span><span class=p>(</span><span class=n>rooms</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>rooms</span>
</span></span><span class=line><span class=cl>    <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>map</span><span class=p>(</span><span class=k>fn</span> <span class=n>room</span> <span class=o>-&gt;</span> <span class=n>room</span><span class=o>.</span><span class=n>probability</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>reduce</span><span class=p>(</span><span class=k>fn</span> <span class=n>room</span><span class=p>,</span> <span class=n>acc</span> <span class=o>-&gt;</span> <span class=n>room</span> <span class=o>++</span> <span class=n>acc</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>random</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span></code></pre></div><p>and finally now that I know the biased random outcome-</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Elixir data-lang=Elixir><span class=line><span class=cl>    <span class=n>rooms</span>
</span></span><span class=line><span class=cl>    <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=k>fn</span> <span class=n>room</span> <span class=o>-&gt;</span> <span class=n>room</span><span class=o>.</span><span class=n>name</span> <span class=o>==</span> <span class=n>bias_probability</span><span class=p>(</span><span class=n>rooms</span><span class=p>)</span> <span class=k>end</span><span class=p>)</span>
</span></span></code></pre></div><p>Technically? This is a mathematically correct solution. It will compute a random value with a biased probability of
<code>P(0.1, 0.5, 0.3)</code>. I felt happy with myself, turned off my laptop and went to sleep! That was that! Or so I thought.</p><p>See there are two fundamental flaws of this approach:</p><ol><li><p><em>I&rsquo;m hard coding the probabilities, although modifying the probability of a room is possible, it will result in
boiler plate code and unnecessary list traversal</em></p></li><li><p><em>The algorithm is not performant(in space complexity) atoms are not garbage collected in Elixir, and it would be
unwise to arbitrarily create them on a whim! suppose I had a thousand rooms in the future for example</em></p></li></ol><p>Sure enough, extra feature requirements came, the addition of a &ldquo;difficulty level&rdquo; that will bias this probability
dynamically. So.. began my search, with a renewed courage to try mathematical problems I tweaked and tweaked, no luck.
I asked my friends in engineering from school no luck! and then sure enough, a friend of mine with superior googling
skill found a long lost blog post from 2017. This is what really helped me, without it I was lost in meaningless
scribbles of probability theory and conditional problems. If you&rsquo;re interested in learning more about implementing a
weighted probability algorithm please check out <a href=https://blog.bruce-hill.com/a-faster-weighted-random-choice>David Hills&rsquo;s blog</a>
it&rsquo;s really detailed and well done! I&rsquo;ll focus on implementing two algorithmic approaches I learned and adapting it to
the context of this game. The linear search and one of the alias algorithms.</p><h2 id=probabilities-can-be-unfair>Probabilities can be unfair!</h2><h3 id=linear-scan-the-okay-method>Linear scan the O(kay) method</h3><p><em>O(n) runtime</em></p><p>A lovely idea is to search the linked list for an index value based on probable outcomes, wish I thought of this!!
This will work by generating a random number between <code>0 - 1</code> and multiply that by the total probability distribution
(For my use case, I&rsquo;m assuming the list is sorted), then traverse the probability distribution subtracting each
probability from the random probability, if it goes below zero? We&rsquo;ve exhausted the probability distribution and
found the index we need. Lovely solution. This works because we mathematically assume <code>random.random()</code>
will generate a perfectly random number(spoiler it doesn&rsquo;t, but we don&rsquo;t care). If the probability is really low?
It will hit the lowest index less often, and if the probability is high? It will hit that index more often. Run the code
below to get a sense of it if you like.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>weighted_random</span><span class=p>(</span><span class=n>weights</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    INPUT probabilities - [0.2, 0.3, 0.5]
</span></span></span><span class=line><span class=cl><span class=s2>    OUTPUT index of random_weight - [0, 1, 2]
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>remaining_distance</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>random</span><span class=p>()</span> <span class=o>*</span> <span class=nb>sum</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># probability distribution sample size * random integer</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>weight</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>weights</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># [{0, 0.2}, {1, 0.3}, {2, 0.5}]</span>
</span></span><span class=line><span class=cl>        <span class=n>remaining_distance</span> <span class=o>-=</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1>#print(&#34;debug&#34;, remaining_distance)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>remaining_distance</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Repeat the experiment to observe bias factor</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>e</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;exp trial</span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span><span class=n>weighted_random</span><span class=p>([</span><span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>]))</span>
</span></span></code></pre></div><p>This seems really cool doesn&rsquo;t it? I can represent the P(n) of my game as floats and dynamically update them,
keeping the purity of the function. A quick and dirty Elixir version of this looks like</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Elixir data-lang=Elixir><span class=line><span class=cl><span class=kd>defmodule</span> <span class=nc>Prob</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=kd>def</span> <span class=n>bias_probability</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=c1># [i[0] P=0.2, i[1] P=0.5 , i[2] P=0.3] s.s = 3</span>
</span></span><span class=line><span class=cl>    <span class=c1># P(n) = distribution sample len bias * random() - P[i] &lt; 0</span>
</span></span><span class=line><span class=cl>    <span class=n>len</span> <span class=o>=</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>count</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># could increase range for greater float precision as you like</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span> <span class=o>=</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>random</span><span class=p>(</span><span class=mi>1</span><span class=o>..</span><span class=mi>99</span><span class=p>)</span><span class=o>/</span><span class=mi>100</span> <span class=o>*</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># bias factor</span>
</span></span><span class=line><span class=cl>    <span class=n>enumerated_list</span> <span class=o>=</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>zip</span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=n>len</span><span class=p>,</span> <span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nc>Enum</span><span class=o>.</span><span class=n>reduce_while</span><span class=p>(</span><span class=n>enumerated_list</span><span class=p>,</span> <span class=n>distance</span><span class=p>,</span> <span class=k>fn</span> <span class=p>(</span><span class=n>_weight</span> <span class=o>=</span> <span class=p>{</span><span class=n>i</span><span class=p>,</span> <span class=n>w</span><span class=p>},</span> <span class=n>acc</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>acc</span> <span class=o>-</span> <span class=n>w</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>,</span> <span class=ss>do</span><span class=p>:</span> <span class=p>{</span><span class=ss>:cont</span><span class=p>,</span> <span class=n>acc</span> <span class=o>-</span> <span class=n>w</span><span class=p>},</span> <span class=ss>else</span><span class=p>:</span> <span class=p>{</span><span class=ss>:halt</span><span class=p>,</span> <span class=n>i</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nc>IO</span><span class=o>.</span><span class=n>inspect</span> <span class=nc>Prob</span><span class=o>.</span><span class=n>bias_probability</span><span class=p>([</span><span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>])</span>
</span></span></code></pre></div><p>and then to find the biased index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Elixir data-lang=Elixir><span class=line><span class=cl>    <span class=n>rooms</span>
</span></span><span class=line><span class=cl>    <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>map</span><span class=p>(</span><span class=k>fn</span> <span class=n>room</span> <span class=o>-&gt;</span> <span class=n>room</span><span class=o>.</span><span class=n>probability</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>fetch</span><span class=p>(</span><span class=n>bias_probability</span><span class=p>(</span><span class=n>rooms</span><span class=p>))</span>
</span></span></code></pre></div><p>but now that I&rsquo;ve gone through the trouble of investigating weighted probability, I don&rsquo;t wanna settle for a linear search. Might as well make the game with the fastest possible approach. Let&rsquo;s go back in history, and take a look at one of the <a href=https://en.wikipedia.org/wiki/Alias_method>alias algorithms</a>.</p><h3 id=aliasingvose-the-o-yes-method>Aliasing(Vose) the O yes! method</h3><p><em>O(n) alias table prep + O(1) lookup</em></p><p>This one is a bit tricky to understand at first. If you&rsquo;re interested in a much more technical deep dive into the various
approaches for solving this problem, please check out this <a href=https://www.keithschwarz.com/darts-dice-coins/>article by Keith Schwarz</a>
it&rsquo;s dense, comprehensive and technical. Onto aliasing!</p><p>The idea is honestly very clever! and in my opinion counter-intuitive, which is what makes it&rsquo;s constant-time runtime
lookup so impressive. Let&rsquo;s take a step back, before diving in. An alias is like a nickname we give to stuff right?
You have a friend called Samuel, and you call him Sam. His name isn&rsquo;t Sam and he hates that nickname, but alas, it
stuck&mldr; poor Samuel, but if you see his face anywhere you know Sam is Samuel because you&rsquo;re such good friends.
The alias method is a lot like this in principle. You have a biased probability weight distribution and it
<em>approaches some limit</em> and that limit can be used to generate a custom distribution. Let&rsquo;s talk about Sam for a bit.</p><p>See Sam&rsquo;s nickname is called an <code>alias table</code> and your friendship(how you know Sam is Samuel) is the algorithm.
Now that we have some hint as to what we&rsquo;re doing, here&rsquo;s the python implementation with my comments from Bruce Hill&rsquo;s blog.
Scan through it, maybe run it if you&rsquo;re adventurous. We&rsquo;ll break it down step by step next.
(If you&rsquo;re familiar with Java check out <a href="https://www.keithschwarz.com/interesting/code/?dir=alias-method">Keith Schwarz&rsquo;s implementation instead</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>prepare_aliased_randomizer</span><span class=p>(</span><span class=n>weights</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>N</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span> <span class=c1># limit</span>
</span></span><span class=line><span class=cl>    <span class=n>avg</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span><span class=o>/</span><span class=n>N</span> <span class=c1># alias partition</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>aliases</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>1</span><span class=p>,</span> <span class=kc>None</span><span class=p>)]</span> <span class=o>*</span> <span class=n>N</span>
</span></span><span class=line><span class=cl>    <span class=c1># [(1, None), (1, None), (1, None)] --&gt; alias table</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Bucketting (pseudo quick sort like behaviour*)</span>
</span></span><span class=line><span class=cl>    <span class=c1># weight/avg &lt; | &gt; avg</span>
</span></span><span class=line><span class=cl>    <span class=c1># smalls are partial alias fits</span>
</span></span><span class=line><span class=cl>    <span class=c1># bigs fits and remainder thrown to smalls</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>smalls</span> <span class=o>=</span> <span class=p>((</span><span class=n>i</span><span class=p>,</span> <span class=n>w</span><span class=o>/</span><span class=n>avg</span><span class=p>)</span> <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>w</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span> <span class=k>if</span> <span class=n>w</span> <span class=o>&lt;</span> <span class=n>avg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>bigs</span> <span class=o>=</span> <span class=p>((</span><span class=n>i</span><span class=p>,</span> <span class=n>w</span><span class=o>/</span><span class=n>avg</span><span class=p>)</span> <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>w</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span> <span class=k>if</span> <span class=n>w</span> <span class=o>&gt;=</span> <span class=n>avg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># [(0, 0.6), (1, 0.9)] --&gt; small weight avgs</span>
</span></span><span class=line><span class=cl>    <span class=c1># [(2, 1.5)] --&gt; big weight avgs</span>
</span></span><span class=line><span class=cl>    <span class=c1>#cycle through small and big partition generator</span>
</span></span><span class=line><span class=cl>    <span class=n>small</span><span class=p>,</span> <span class=n>big</span> <span class=o>=</span> <span class=nb>next</span><span class=p>(</span><span class=n>smalls</span><span class=p>,</span> <span class=kc>None</span><span class=p>),</span> <span class=nb>next</span><span class=p>(</span><span class=n>bigs</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># if elems are not exhauted kindly loop</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>big</span> <span class=ow>and</span> <span class=n>small</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># put the partial elem in aliases</span>
</span></span><span class=line><span class=cl>        <span class=n>aliases</span><span class=p>[</span><span class=n>small</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>=</span> <span class=p>(</span><span class=n>small</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>big</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;alias lookup table transformation&#34;</span><span class=p>,</span> <span class=n>aliases</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># big = i of big , weight_b - (1 - weight_s)</span>
</span></span><span class=line><span class=cl>        <span class=c1># big = (0, (1.5 - (1 - 0.6))</span>
</span></span><span class=line><span class=cl>        <span class=n>big</span> <span class=o>=</span> <span class=p>(</span><span class=n>big</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>big</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=p>(</span><span class=mi>1</span><span class=o>-</span><span class=n>small</span><span class=p>[</span><span class=mi>1</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>big</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;large weight is &lt; 1 skip&#34;</span><span class=p>,</span> <span class=n>aliases</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>small</span> <span class=o>=</span> <span class=n>big</span>
</span></span><span class=line><span class=cl>            <span class=n>big</span> <span class=o>=</span> <span class=nb>next</span><span class=p>(</span><span class=n>bigs</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>small</span> <span class=o>=</span> <span class=nb>next</span><span class=p>(</span><span class=n>smalls</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;alias table generated&#34;</span><span class=p>,</span> <span class=n>aliases</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># SELECTION STAGE</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>weighted_random</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>r</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>random</span><span class=p>()</span> <span class=o>*</span> <span class=n>N</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># choose a random probability</span>
</span></span><span class=line><span class=cl>        <span class=c1># from the alias table</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>odds</span><span class=p>,</span> <span class=n>alias</span><span class=p>)</span> <span class=o>=</span> <span class=n>aliases</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;what are the odds of&#34;</span><span class=p>,</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># return the larger probability if</span>
</span></span><span class=line><span class=cl>        <span class=c1># it&#39;s odds are higher else</span>
</span></span><span class=line><span class=cl>        <span class=c1># return the smaller probability index</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>alias</span> <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-</span><span class=n>i</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>odds</span> <span class=k>else</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>weighted_random</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># single trial selection</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;experiment trial&#34;</span><span class=p>,</span> <span class=n>prepare_aliased_randomizer</span><span class=p>([</span> <span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>,</span> <span class=mf>0.</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Repeat the experiment to observe bias factor</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>e</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;experiment trial&#34;</span><span class=p>,</span> <span class=n>prepare_aliased_randomizer</span><span class=p>([</span><span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>]))</span>
</span></span></code></pre></div><p>PHEWW!!!!!!! there&rsquo;s alot going on. Let&rsquo;s break it down. There are two major steps, once you understand how the table is
generated(that&rsquo;s most of the work) the lookup naturally follows.</p><p><em><strong>This paragraph is interesting but ultimately a digression, you can choose to skip over it!</strong></em>
<em>How exactly does a computer remember who Sam is? Well computers are a little like the human brain, people have complex organic circuitry of neurons that consolidate sensory observation and from that recognizes patterns and form &ldquo;thoughts&rdquo;, the only difference is we have to tell the computer what pattern it should follow and it doesn&rsquo;t necessary form a thought, simply a result, and we do not need such instructions?(dna? nope, it&rsquo;s a philosophical question of not only intelligence but implicitly will :) does existence precede essence? I like to think so. Shameless plug, @ me on <a href=https://twitter.com/haile_lagi>twitter</a> if you&rsquo;re interested in this topic).</em></p><h4 id=table-generation>Table generation</h4><p>To create the table, the original weight distribution is sliced into pieces(partitions)! Quite literally! Suppose we
know how many weights we need, in this case 3, that&rsquo;s the limit. To find <code>P(0.2, 0.3, 0.5)</code> We create an empty alias,
with a data structure, with the exact same length <code>[partition, partition, partition]</code> and a probability
<code>[partition, partition, partition]</code>. Each partition will contain exactly <code>P(1/3)</code>. Here&rsquo;s the interesting part, we then
scale the probabilities to the factor of our limit and separate it into chunks <code>less than 1</code> and <code>greater than or equal to 1</code>. Why?</p><p>Here is the rationale:</p><ol><li><p>If the weight fraction is greater than one or equal to it, it will fill a single alias partition(fit exactly if equal else)
with some change! which will be sent to an empty partition.</p></li><li><p>If the weight is less than one, then it will be smaller than the allocated partition and it will be expecting a buddy :)</p></li></ol><p>Each partition, will hold a new distribution perfectly and why this is mathematically correct.. is kinda funny tbh.
I won&rsquo;t discuss the formal proof, but the idea is that at any point in time, the sum of the elements in the distribution
is always proportionate to the original weight.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Elixir data-lang=Elixir><span class=line><span class=cl><span class=kd>defmodule</span> <span class=nc>Probability</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=kd>def</span> <span class=n>bias_probability</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=c1># Initialization</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>count</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>prepare_alias_table</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>defp</span> <span class=n>prepare_alias_table</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>alias_table</span> <span class=o>=</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>map</span><span class=p>(</span><span class=mi>1</span><span class=o>..</span><span class=n>n</span><span class=p>,</span> <span class=k>fn</span> <span class=n>_</span> <span class=o>-&gt;</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=no>nil</span><span class=p>}</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>prob</span> <span class=o>=</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>map</span><span class=p>(</span><span class=mi>1</span><span class=o>..</span><span class=n>n</span><span class=p>,</span> <span class=k>fn</span> <span class=n>_</span> <span class=o>-&gt;</span> <span class=no>nil</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># create work lists</span>
</span></span><span class=line><span class=cl>    <span class=n>scaled_weight</span> <span class=o>=</span> <span class=n>scale_probability</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>small</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=n>scaled_weight</span>
</span></span><span class=line><span class=cl>      <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>filter</span><span class=p>(</span><span class=k>fn</span> <span class=p>{</span><span class=n>_</span><span class=p>,</span> <span class=n>w</span><span class=p>}</span> <span class=o>-&gt;</span> <span class=n>w</span> <span class=o>&lt;</span> <span class=mi>1</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>large</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=n>scaled_weight</span>
</span></span><span class=line><span class=cl>      <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>filter</span><span class=p>(</span><span class=k>fn</span> <span class=p>{</span><span class=n>_</span><span class=p>,</span> <span class=n>w</span><span class=p>}</span> <span class=o>-&gt;</span> <span class=n>w</span> <span class=o>&gt;=</span> <span class=mi>1</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># recursively create table (TCO optimized)</span>
</span></span><span class=line><span class=cl>    <span class=n>transform_alias</span><span class=p>(</span><span class=n>small</span><span class=p>,</span> <span class=n>large</span><span class=p>,</span> <span class=n>alias_table</span><span class=p>,</span> <span class=n>prob</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># Base case when small and large are empty</span>
</span></span><span class=line><span class=cl>  <span class=kd>defp</span> <span class=n>transform_alias</span><span class=p>([],</span> <span class=p>[],</span> <span class=n>_</span><span class=p>,</span> <span class=n>prob</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>prob</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>defp</span> <span class=n>transform_alias</span><span class=p>(</span><span class=n>small</span> <span class=o>=</span> <span class=p>[],</span> <span class=p>[</span><span class=n>_g</span> <span class=o>=</span> <span class=p>{</span><span class=n>i</span><span class=p>,</span> <span class=n>_</span><span class=p>}</span> <span class=o>|</span> <span class=n>tail</span><span class=p>],</span> <span class=n>alias_table</span><span class=p>,</span> <span class=n>prob</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=c1># Remove the first element from large call it g, Set prob[g] = 1</span>
</span></span><span class=line><span class=cl>    <span class=n>transform_alias</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>small</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>tail</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>alias_table</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nc>List</span><span class=o>.</span><span class=n>replace_at</span><span class=p>(</span><span class=n>prob</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>defp</span> <span class=n>transform_alias</span><span class=p>([</span><span class=n>_l</span> <span class=o>=</span> <span class=p>{</span><span class=n>i</span><span class=p>,</span> <span class=n>_</span><span class=p>}</span> <span class=o>|</span> <span class=n>tail</span><span class=p>],</span> <span class=n>large</span> <span class=o>=</span> <span class=p>[],</span> <span class=n>alias_table</span><span class=p>,</span> <span class=n>prob</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=c1># (clause will trigger due to numerical instability)</span>
</span></span><span class=line><span class=cl>    <span class=c1># Remove the first element from Small, call it l</span>
</span></span><span class=line><span class=cl>    <span class=n>transform_alias</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>tail</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>large</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>alias_table</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nc>List</span><span class=o>.</span><span class=n>replace_at</span><span class=p>(</span><span class=n>prob</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>defp</span> <span class=n>transform_alias</span><span class=p>(</span>
</span></span><span class=line><span class=cl>         <span class=p>[{</span><span class=n>index_l</span><span class=p>,</span> <span class=n>weight_l</span><span class=p>}</span> <span class=o>|</span> <span class=n>tail_s</span><span class=p>],</span>
</span></span><span class=line><span class=cl>         <span class=p>[</span><span class=n>_g</span> <span class=o>=</span> <span class=p>{</span><span class=n>index_g</span><span class=p>,</span> <span class=n>weight_g</span><span class=p>}</span> <span class=o>|</span> <span class=n>tail_l</span><span class=p>],</span>
</span></span><span class=line><span class=cl>         <span class=n>alias_table</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=n>prob</span>
</span></span><span class=line><span class=cl>       <span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=c1># Remove the first element from small call it l</span>
</span></span><span class=line><span class=cl>    <span class=c1># Remove the first element from large call it g</span>
</span></span><span class=line><span class=cl>    <span class=c1># Pg := (pg + pl) - 1 (numerical stability :) )</span>
</span></span><span class=line><span class=cl>    <span class=n>new_weight_g</span> <span class=o>=</span> <span class=p>(</span><span class=n>weight_g</span> <span class=o>+</span> <span class=n>weight_l</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># if Pg &lt; 1 add g to small</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>new_weight_g</span> <span class=o>&lt;</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>      <span class=n>transform_alias</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=p>[{</span><span class=n>index_g</span><span class=p>,</span> <span class=n>new_weight_g</span><span class=p>}</span> <span class=o>|</span> <span class=n>tail_s</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=n>tail_l</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nc>List</span><span class=o>.</span><span class=n>replace_at</span><span class=p>(</span><span class=n>alias_table</span><span class=p>,</span> <span class=n>index_l</span><span class=p>,</span> <span class=n>weight_g</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=nc>List</span><span class=o>.</span><span class=n>replace_at</span><span class=p>(</span><span class=n>prob</span><span class=p>,</span> <span class=n>index_l</span><span class=p>,</span> <span class=n>weight_l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1># else Pg &gt;= 1 add g to large</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>transform_alias</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>tail_s</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>[{</span><span class=n>index_g</span><span class=p>,</span> <span class=n>new_weight_g</span><span class=p>}</span> <span class=o>|</span> <span class=n>tail_l</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=nc>List</span><span class=o>.</span><span class=n>replace_at</span><span class=p>(</span><span class=n>alias_table</span><span class=p>,</span> <span class=n>index_l</span><span class=p>,</span> <span class=n>weight_g</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=nc>List</span><span class=o>.</span><span class=n>replace_at</span><span class=p>(</span><span class=n>prob</span><span class=p>,</span> <span class=n>index_l</span><span class=p>,</span> <span class=n>weight_l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>  <span class=c1># HELPER</span>
</span></span><span class=line><span class=cl>  <span class=kd>defp</span> <span class=n>scale_probability</span><span class=p>(</span><span class=n>probs</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=mi>0</span><span class=o>..</span><span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>zip</span><span class=p>(</span><span class=n>probs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|&gt;</span> <span class=nc>Stream</span><span class=o>.</span><span class=n>map</span><span class=p>(</span><span class=k>fn</span> <span class=p>{</span><span class=n>i</span><span class=p>,</span> <span class=n>w</span><span class=p>}</span> <span class=o>-&gt;</span> <span class=p>{</span><span class=n>i</span><span class=p>,</span> <span class=n>w</span> <span class=o>*</span> <span class=n>n</span><span class=p>}</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>Now that we can generate an alias table, this implementation will also include a local cache using
<a href=http://erlang.org/doc/man/ets.html>Erlang Term Storage</a> to hold the alias table inside another table!
throughout the lifecycle of the application once it has begun to run. I&rsquo;m assuming once a difficulty level is selected
random rooms need to be populated but the probability of that room occuring needs to be computed once.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Elixir data-lang=Elixir><span class=line><span class=cl>  <span class=kd>def</span> <span class=n>bias_probability</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=c1># Initialization</span>
</span></span><span class=line><span class=cl>    <span class=c1># does the probability exist in memory?</span>
</span></span><span class=line><span class=cl>    <span class=n>current_probability</span> <span class=o>=</span> <span class=k>try</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>      <span class=p>[</span><span class=ss>weights</span><span class=p>:</span> <span class=n>cached_probs</span><span class=p>]</span> <span class=o>=</span> <span class=ss>:ets</span><span class=o>.</span><span class=n>lookup</span><span class=p>(</span><span class=ss>:weight_probability</span><span class=p>,</span> <span class=ss>:weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>cached_probs</span>
</span></span><span class=line><span class=cl>    <span class=k>rescue</span>
</span></span><span class=line><span class=cl>      <span class=nc>ArgumentError</span> <span class=o>-&gt;</span> <span class=n>cache</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>current_probability</span>
</span></span><span class=line><span class=cl>    <span class=c1>#|&gt; weighted_random # to be implemented next</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>defp</span> <span class=n>cache</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>count</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=ss>:ets</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=ss>:weight_probability</span><span class=p>,</span> <span class=p>[</span><span class=ss>:duplicate_bag</span><span class=p>,</span> <span class=ss>:private</span><span class=p>,</span> <span class=ss>:named_table</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=ss>:ets</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=ss>:weight_probability</span><span class=p>,</span> <span class=p>{</span><span class=ss>:weights</span><span class=p>,</span> <span class=n>prepare_alias_table</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>n</span><span class=p>)})</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=ss>weights</span><span class=p>:</span> <span class=n>cached_probs</span><span class=p>]</span> <span class=o>=</span> <span class=ss>:ets</span><span class=o>.</span><span class=n>lookup</span><span class=p>(</span><span class=ss>:weight_probability</span><span class=p>,</span> <span class=ss>:weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cached_probs</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span></code></pre></div><h4 id=look-up>Look up</h4><p>Finally we can generate a random probability and select an index to return from it!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Elixir data-lang=Elixir><span class=line><span class=cl>  <span class=c1># GENERATION</span>
</span></span><span class=line><span class=cl>  <span class=kd>defp</span> <span class=n>weighted_random</span><span class=p>(</span><span class=n>aliased_table</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=c1># Generate a fair random distro in a range</span>
</span></span><span class=line><span class=cl>    <span class=c1># from n and call it i.</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>random</span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=mi>1000</span><span class=p>)</span><span class=o>/</span><span class=mi>1000</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=c1># random choice P(1/3)</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>floor</span><span class=p>(</span><span class=n>r</span><span class=p>)</span> <span class=c1># 0, 1 , 2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>prob</span> <span class=o>=</span> <span class=n>aliased_table</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=ss>:ok</span><span class=p>,</span> <span class=n>odd</span><span class=p>}</span> <span class=o>=</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>fetch</span><span class=p>(</span><span class=n>prob</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># partial fit</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>-</span> <span class=n>i</span><span class=p>)</span> <span class=o>&gt;</span> <span class=p>(</span><span class=n>odd</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>      <span class=c1># which piece of what goes where</span>
</span></span><span class=line><span class=cl>      <span class=n>bias</span> <span class=o>=</span> <span class=n>prob</span>
</span></span><span class=line><span class=cl>      <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>with_index</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=o>|&gt;</span> <span class=nc>Stream</span><span class=o>.</span><span class=n>filter</span><span class=p>(</span><span class=k>fn</span> <span class=p>{</span><span class=n>p</span><span class=p>,</span> <span class=n>_</span><span class=p>}</span> <span class=o>-&gt;</span> <span class=n>p</span> <span class=o>==</span> <span class=mi>1</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>random</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>{</span><span class=n>_</span><span class=p>,</span> <span class=n>i</span><span class=p>}</span> <span class=o>=</span> <span class=n>bias</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>       <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span></code></pre></div><p>Here&rsquo;s the whole implementation in a <a href=https://gist.github.com/hailelagi/553d0af87209f21516be8fb53bcdf453>Github gist</a></p><h2 id=gotchas>GOTCHAS</h2><p>There are quite a few waiting for you if you desire to copy/paste this implementation, for example I ignored float
point precision(somewhat) instead I could have chosen to seed the values and <em>my probabilities are always weight fractions of 1</em>,
or the implicit assumption of never returning 0, or 1 weights in the linear search. Please read the more indepth blogs,
they&rsquo;re invaluable. For my use case though, it could probably scale to thousands of rooms effortlessly.</p><p>Thanks for reading!!! I&rsquo;m always looking for feedback, have a suggestion? found a bug? Know an interesting algorithm?
Maybe you just wanna leave kind words, I&rsquo;m always happy to converse :)</p></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>source</a>
Copyright © 2024 Haile Lagi<div id=sign-key><span>GPG key ID: 0298F4203ADC85E8</span></div></footer></body></html>