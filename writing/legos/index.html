<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel="shortcut icon" href=https://www.hailelagi.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>It's legos all the way down</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href="https://app.zerion.io/0x3430b8b776c531e01736ddfc15b11d9e14afe793/overview?name=haile.eth" title=ethereum>ethereum</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/readme title=readme>readme</a></li><li><a href=/resume title=resume>resume</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>It's legos all the way down</h1><time>January 25, 2023</time></header><p>Often as folks who create useful software things we tend to think of ourselves as people who write software for &ldquo;users&rdquo;. A &ldquo;user&rdquo; clicks a button and
something magical happens. This is what is commonly reffered to as an <a href=https://en.wikipedia.org/wiki/Abstraction_(computer_science)>abstraction</a>.
Abstractions are all around us in software and clever programmers create abstractions for other programmers to save them valuable time and or other resources.</p><p>A really common example of this is an <a href=https://en.wikipedia.org/wiki/API>Application Programming Interface</a> which allows two &ldquo;applications&rdquo; to talk to each other over
some transport. Like an API, there are other interesting kinds of abstractions &ndash; let&rsquo;s talk about the one between the language creator and language user by creating an
<a href=https://en.wikipedia.org/wiki/Array_(data_structure)>array</a> in elixir.</p><p>Before we begin! A caveat. Although the concepts here apply broadly to most modern languages, it is most convenient to explore these concepts explicity with a language that has at least
made some kind of provision for them, I&rsquo;ll try to primarily include alternate examples with go&rsquo;s <a href=https://go.dev/blog/laws-of-reflection>reflection</a> and rust&rsquo;s macros while providing references
for exploring the AST for Cpython and MRIRuby (javascript sadly not included![1])</p><h3 id=building-a-dynamic-array-constructor-in-elixir>Building a (Dynamic) Array &ldquo;constructor&rdquo; in Elixir</h3><p>First, some background. Elixir is a (mostly) functional language with (mostly) immutable datastructures, it doesn&rsquo;t provide a dynamic array out of the box, as the implementation of one
requires internally mutable state. If you <em>really</em> need one though, you can reach into the <a href=https://www.erlang.org/doc/man/array.html>erlang stdlib</a>.</p><p>For this we&rsquo;re going to piggyback of the rust standard library&rsquo;s <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html>Vector</a> and
creating a <a href=https://en.wikipedia.org/wiki/Foreign_function_interface>foreign function interface</a> in elixir by re-creating rust&rsquo;s <code>vec!</code> macro api.
Here&rsquo;s a simplified version pull straight from the rust book of what this looks like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[macro_export]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>macro_rules!</span><span class=w> </span><span class=n>vec</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=w> </span><span class=cp>$(</span><span class=w> </span><span class=cp>$x</span>:<span class=nc>expr</span><span class=w> </span><span class=p>),</span><span class=o>*</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>temp_vec</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=cp>$(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>temp_vec</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=cp>$x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>)</span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>temp_vec</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>In elixir we can begin like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>defmodule</span> <span class=nc>Vector</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=kd>defmacro</span> <span class=n>vec!</span><span class=p>(</span><span class=n>arguments</span><span class=p>,</span> <span class=ss>do</span><span class=p>:</span> <span class=n>expression</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=k>quote</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>      <span class=nc>Array</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=n>arguments</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><h3 id=foot-notes>Foot notes</h3><p>[1] I don&rsquo;t touch on Javascript(ECMAScript) as the language itself doesn&rsquo;t provide (afaik) useful apis to introspect it&rsquo;s compile time state at runtime,
added to that is the balloned complexity of <em>which</em> version of the AST, by which engine is produced and you get unwanted complexity that is out of scope.
(<a href=https://nodejs.dev/en/learn/the-v8-javascript-engine/>https://nodejs.dev/en/learn/the-v8-javascript-engine/</a>)</p><p>[2] AST reference: <a href=https://github.com/elixir-lang/elixir/blob/d8f1a5d6b653c14ae44c6eacdbc8e9df7006d284/lib/elixir/pages/syntax-reference.md#the-elixir-ast>https://github.com/elixir-lang/elixir/blob/d8f1a5d6b653c14ae44c6eacdbc8e9df7006d284/lib/elixir/pages/syntax-reference.md#the-elixir-ast</a></p></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>source</a>
Copyright © 2022 Haile Lagi</footer></body></html>