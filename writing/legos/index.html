<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel="shortcut icon" href=https://www.hailelagi.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>It's legos all the way down</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href="https://app.zerion.io/0x3430b8b776c531e01736ddfc15b11d9e14afe793/overview?name=haile.eth" title=ethereum>ethereum</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/readme title=readme>readme</a></li><li><a href=/resume title=resume>resume</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>It's legos all the way down</h1><time>January 25, 2023</time></header><p>Often as folks who create useful software things we tend to think of ourselves as people who write software for the mythical &ldquo;user&rdquo;. A &ldquo;user&rdquo; clicks a button and
something magical happens. This is commonly reffered to as an <a href=https://en.wikipedia.org/wiki/Abstraction_(computer_science)>abstraction</a>.
Abstractions are all around us in software and clever programmers create good abstractions for other programmers to save them valuable time and or other resources.</p><p>A really common example of this is an <a href=https://en.wikipedia.org/wiki/API>Application Programming Interface</a> which allows two &ldquo;applications&rdquo; to talk to each other over
some transport. Like an API, there are other interesting kinds of abstractions &ndash; let&rsquo;s talk about the one between the language creator and language user by <em>inventing
syntax!</em></p><p>How? we&rsquo;ll define a <a href=https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)>constructor</a> for a <a href=https://en.wikipedia.org/wiki/Dynamic_array>dynamic array</a> in <code>elixir</code>.</p><p>This involves a subtle shift in the paradigm used to understand computation, at the core is the idea of viewing <em>computation</em> as <em>data</em>. I would guess for most people,
the typical mental model when reading at first is mostly <em>procedural</em>, a top-down scan with familiarity of syntax and semantics, then another important shift occurs in
understanding runtime execution with the introduction of concurrency and parallelism, here we&rsquo;ll be peeling back at the layer between <em>compile time</em> and <em>runtime</em>.</p><p>Before we begin, a caveat. Although metaprogramming applies broadly to most modern languages &ndash; implementations vary in feature parity, I&rsquo;ll try to primarily include alternate examples with go&rsquo;s <a href=https://go.dev/blog/laws-of-reflection>reflection</a> and rust&rsquo;s <a href=https://doc.rust-lang.org/book/ch19-06-macros.html>macro system</a> while providing nods to Cpython<a href=#references>[1]</a>, Ruby MRI<a href=#references>[2]</a> and some javascript <a href=#references>[3]</a>) but not typescript<a href=#references>[4]</a></p><h3 id=ast-what>AST what?</h3><p>Abstract Syntax Tree. Okay but what is it? As this is intended to be written in a more hands-on style, at the risk
of oversimplification, think of an AST as a way to meaningfully represent the textual source of a program that sometimes allows you to do something resembling <a href=https://en.wikipedia.org/wiki/String_interpolation>string interpolation</a> operations on your program&rsquo;s text source. Consider for example the humble <code>eval()</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// javascript
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>eval</span><span class=p>(</span><span class=s1>&#39;2 + 2&#39;</span><span class=p>));</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python3 data-lang=python3><span class=line><span class=cl><span class=c1># python</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>eval</span><span class=p>(</span><span class=s1>&#39;2 + 2&#39;</span><span class=p>))</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=c1># ruby</span>
</span></span><span class=line><span class=cl><span class=nb>puts</span> <span class=nb>eval</span><span class=p>(</span><span class=s1>&#39;2 + 2&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>The computation <code>2 + 2</code> is represented as data, in this case a <code>string</code>. That&rsquo;s kind of neat isn&rsquo;t it? however we can take this much futher.
If you&rsquo;re interested in the details of what&rsquo;s happening here, checkout <a href=https://craftinginterpreters.com/>crafting interpreters</a>.</p><h3 id=prelude-why-meta>Prelude, why meta?</h3><p>First, some background. Elixir is a (mostly) functional language with (mostly) immutable datastructures, it doesn&rsquo;t encourage the use of
or provide a dynamic array out of the box like most functional languages, as the implementation of one
requires random access read/write via mutable state. Nor does it have &ldquo;constructors&rdquo;, a typical pattern is creating an instance of data returned from
a function and <a href=https://elixirschool.com/en/lessons/basics/pipe_operator>&ldquo;piping&rdquo;</a> it through several other functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>defmodule</span> <span class=nc>MyApp.Array</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=kd>defstruct</span> <span class=ss>field</span><span class=p>:</span> <span class=no>nil</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>def</span> <span class=n>new</span><span class=p>(</span><span class=n>options</span> <span class=p>\\</span> <span class=p>[])</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>__MODULE__</span><span class=p>{</span><span class=ss>field</span><span class=p>:</span> <span class=n>options</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>&gt;</span> <span class=nc>MyApp.Array</span><span class=o>.</span><span class=n>new</span><span class=p>()</span> <span class=o>|&gt;</span> <span class=n>do_stuff</span><span class=p>()</span> <span class=o>|&gt;</span> <span class=n>do_other_stuff</span><span class=p>()</span>
</span></span></code></pre></div><p>For this example, we&rsquo;re going to piggyback off the rust standard library&rsquo;s <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html>Vector</a> by
creating a <a href=https://en.wikipedia.org/wiki/Foreign_function_interface>foreign function interface</a> in elixir and utilizing a data structure implemented in the <a href=https://www.erlang.org/doc/man/array.html>erlang stdlib</a> in order to re-create something like <code>vec!</code></p><p>As we&rsquo;ll see the &ldquo;backend&rdquo; implementation of the data structure is not important, the fact that it&rsquo;s in rust or erlang doesn&rsquo;t matter, what we&rsquo;re focused on is providing an easy to use syntactic abstraction
of a common datastructure.</p><p>Here&rsquo;s a simplified version pulled straight from <a href=https://doc.rust-lang.org/book/ch19-06-macros.html>the rust book</a> of <code>vec!</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[macro_export]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>macro_rules!</span><span class=w> </span><span class=n>vec</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=w> </span><span class=cp>$(</span><span class=w> </span><span class=cp>$x</span>:<span class=nc>expr</span><span class=w> </span><span class=p>),</span><span class=o>*</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>temp_vec</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=cp>$(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>temp_vec</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=cp>$x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>)</span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>temp_vec</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Here we see a pattern match <code>( $( $x:expr ),* )</code> like our humble <code>eval('2 + 2')</code> instead of representing the computation as a string, it&rsquo;s a tree like data-structure
where we can assert at compile time, if some code looks like what we think it looks like, replace it with what&rsquo;s in the match arm,
a process known as <code>macro expansion</code>.</p><p>In elixir, we can write something similar, the pattern match is a three-element style tuple<a href=#references>[5]</a>:</p><p><code>{node, execution_context or meta_data, arguments}</code></p><p>Go and ruby share some superficial similarities as their metaprogramming api doesn&rsquo;t give you direct access to the AST, in ruby DSL&rsquo;s like <code>RSpec</code> and inside <code>rails</code> heavily use metaprogramming techniques via &ldquo;monkey patching&rdquo; &ndash; modifying at <em>runtime</em> various
properties of an object<a href=#references>[6]</a> and since in ruby&rsquo;s <em>extremely dynamic</em> and <em>untyped</em><a href=#references>[7]</a> world there is no notion of &ldquo;compile time expansion&rdquo; during execution but that gives you incredible introspection and malleability via <code>hooks</code><a href=#references>[8]</a> to alter nearly almost anything about the language, syntax or not.</p><p>Take this small excerpt<a href=#references>[9]</a> from <a href=https://github.com/rspec/rspec-core>rspec-core</a> of how <code>describe</code> is defined:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=c1># @private</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nc>self</span><span class=o>.</span><span class=nf>expose_example_group_alias</span><span class=p>(</span><span class=nb>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>if</span> <span class=n>example_group_aliases</span><span class=o>.</span><span class=n>include?</span><span class=p>(</span><span class=nb>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>example_group_aliases</span> <span class=o>&lt;&lt;</span> <span class=nb>name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>class</span> <span class=o>&lt;&lt;</span> <span class=no>RSpec</span><span class=p>;</span> <span class=nb>self</span><span class=p>;</span> <span class=k>end</span><span class=p>)</span><span class=o>.</span><span class=n>__send__</span><span class=p>(</span><span class=ss>:define_method</span><span class=p>,</span> <span class=nb>name</span><span class=p>)</span> <span class=k>do</span> <span class=o>|*</span><span class=n>args</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>example_group_block</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=n>group</span> <span class=o>=</span> <span class=no>RSpec</span><span class=o>::</span><span class=no>Core</span><span class=o>::</span><span class=no>ExampleGroup</span><span class=o>.</span><span class=n>__send__</span><span class=p>(</span><span class=nb>name</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>example_group_block</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=no>RSpec</span><span class=o>.</span><span class=n>world</span><span class=o>.</span><span class=n>record</span><span class=p>(</span><span class=n>group</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>group</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>expose_example_group_alias_globally</span><span class=p>(</span><span class=nb>name</span><span class=p>)</span> <span class=k>if</span> <span class=n>exposed_globally?</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>There&rsquo;s alot happening but the important thing to note is <code>RSpec::Core::ExampleGroup</code> is an object that &ldquo;pun intended&rdquo; is being modified at the test-runner&rsquo;s runtime which describes the linguistic structure of the dsl.</p><p>In go like ruby we have <code>reflection</code> that allows runtime introspection, unlike ruby it is statically typed and compiled. Reflection gives a temporary &ldquo;escape hatch&rdquo; out of the rigid
syntatical constructs and allows modification based on dynamic <code>interfaces</code>, the most idiomatic example of this are the printing family<a href=#references>[10]</a> functions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>pp</span><span class=p>)</span> <span class=nf>doPrint</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=nx>any</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>prevString</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl> <span class=k>for</span> <span class=nx>argNum</span><span class=p>,</span> <span class=nx>arg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>a</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>isString</span> <span class=o>:=</span> <span class=nx>arg</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>arg</span><span class=p>).</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>==</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>String</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Add a space between two non-string arguments.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=nx>argNum</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>isString</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>prevString</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>p</span><span class=p>.</span><span class=nx>buf</span><span class=p>.</span><span class=nf>writeByte</span><span class=p>(</span><span class=sc>&#39; &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>p</span><span class=p>.</span><span class=nf>printArg</span><span class=p>(</span><span class=nx>arg</span><span class=p>,</span> <span class=sc>&#39;v&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>prevString</span> <span class=p>=</span> <span class=nx>isString</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=building-a-dynamic-array-constructor-in-elixir>Building a (Dynamic) Array &ldquo;constructor&rdquo; in Elixir</h3><p>Now we&rsquo;re finally ready! We&rsquo;re going to begin by starting a mix project called <a href=https://github.com/hailelagi/ex_vec><code>ExVec</code></a> and defining a similiar api:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>defmodule</span> <span class=nc>ExVec</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=kd>defmacro</span> <span class=n>vec!</span><span class=p>(</span><span class=n>arguments</span><span class=p>,</span> <span class=ss>do</span><span class=p>:</span> <span class=n>expression</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=k>quote</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>      <span class=nc>ExVec.Vector</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=n>arguments</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>The <code>ex_vec</code> library has two backends <code>ExVec.Array</code> which is a thin wrapper around <code>:array</code> and <code>ExVec.Vector</code> which is a NIF wrapper that
implements what an array might look like in elixir:</p><ol><li>The <code>Access</code> behaviour</li><li>A protocol implementation of <code>Enumerable</code> and <code>Collectable</code></li></ol><p>By specifying these functions we can safely use things from stdlib like <code>Enum</code> and even <code>Stream</code> and just like that in any other elixir project
and letting the client choose the backend:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>defmodule</span> <span class=nc>MyApp.DoStuff</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=kn>use</span> <span class=nc>ExVec</span><span class=p>,</span> <span class=ss>implementation</span><span class=p>:</span> <span class=ss>:rust</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>def</span> <span class=n>len</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>vec!</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>count</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>def</span> <span class=n>map_by_2</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>vec!</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>map</span><span class=p>(</span><span class=k>fn</span> <span class=n>n</span> <span class=o>-&gt;</span> <span class=n>n</span> <span class=o>*</span> <span class=mi>2</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>Thanks for reading!</p><p>You can find the full source for this example <a href=https://github.com/hailelagi/ex_vec>here</a></p><h2 id=references>References</h2><p>[1] Python3&rsquo;s excellent <code>ast</code> library: <a href=https://docs.python.org/3/library/ast.html>https://docs.python.org/3/library/ast.html</a></p><p>[2] RubyVM::AST : <a href=https://ruby-doc.org/core-trunk/RubyVM/AST.html>https://ruby-doc.org/core-trunk/RubyVM/AST.html</a></p><p>[3] Javascript(since ECMAScript6): <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><p>[4] Typescript: <a href=https://basarat.gitbook.io/typescript/overview>https://basarat.gitbook.io/typescript/overview</a></p><p>[4] Go&rsquo;s AST : <a href=https://pkg.go.dev/go/ast>https://pkg.go.dev/go/ast</a></p><p>[5] Elixir&rsquo;s AST: <a href=https://github.com/elixir-lang/elixir/blob/d8f1a5d6b653c14ae44c6eacdbc8e9df7006d284/lib/elixir/pages/syntax-reference.md#the-elixir-ast>https://github.com/elixir-lang/elixir/blob/d8f1a5d6b653c14ae44c6eacdbc8e9df7006d284/lib/elixir/pages/syntax-reference.md#the-elixir-ast</a></p><p>[6] The one true (<em>useful</em>) object to rule them all: <a href=https://ruby-doc.org/3.2.1/Object.html>https://ruby-doc.org/3.2.1/Object.html</a></p><p>[7] Ruby Extensions: <a href=https://docs.ruby-lang.org/en/master/extension_rdoc.html#label-Basic+Knowledge>https://docs.ruby-lang.org/en/master/extension_rdoc.html#label-Basic+Knowledge</a></p><p>[8] Awesome example of the <code>hook pattern</code> into ruby&rsquo;s object lifecyle: <a href=https://github.com/rspec/rspec-core/blob/main/lib/rspec/core/hooks.rb>https://github.com/rspec/rspec-core/blob/main/lib/rspec/core/hooks.rb</a></p><p>[9] RSpec public DSL module: <a href=https://github.com/rspec/rspec-core/blob/main/lib/rspec/core/dsl.rb>https://github.com/rspec/rspec-core/blob/main/lib/rspec/core/dsl.rb</a></p><p>[10] doPrint: <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20:src/fmt/print.go;drc=261fe25c83a94fc3defe064baed3944cd3d16959;l=1204">https://cs.opensource.google/go/go/+/refs/tags/go1.20:src/fmt/print.go;drc=261fe25c83a94fc3defe064baed3944cd3d16959;l=1204</a></p></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>source</a>
Copyright © 2023 Haile Lagi</footer></body></html>