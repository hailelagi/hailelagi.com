<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel="shortcut icon" href=https://www.hailelagi.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Making a Tsunami</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (·àê·ã≠·àå)</a></h2><nav><ul><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/roadmap title=roadmap>roadmap</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Making a Tsunami</h1><time>December 23, 2023</time></header><p>WIP public draft, come back later. <a href=https://github.com/hailelagi/wavl-ets>https://github.com/hailelagi/wavl-ets</a></p><p>Last updated: 12th Jan 2023.</p><h1 id=outline>Outline</h1><p>This was one of the first really hard ambitious things I tried to build, but sadly because of
either a lack time, grit or knowledge/skill I just couldn&rsquo;t make meaningful progress.</p><p>To be fair - at first it <em>seemed</em> like a simple &ldquo;good first issue&rdquo; kind of thing I had no idea what I was opting into, so here&rsquo;s a disclaimer!
We&rsquo;re going to build a type of database! No It&rsquo;s not enough machinery akin to say postgres but there&rsquo;s a fair bit of stuff going on!</p><p>Give or take some pre-requisites:</p><ul><li>some knowledge of programming - you&rsquo;ve built/know what a crud app is</li><li>an idea of rust&rsquo;s ownership system or exposure to some memory management ala C, C++ or Zig</li><li>a rough sense of lexical parsing</li><li>some idea about trees and or graph traversal in general</li><li>some concurrency (shared state or message passing)</li><li>Some knowledge of go&rsquo;s syntax/semantics or a similar C syntax based language like javascript</li></ul><p>This covers some wide ranging and complex important topics, it&rsquo;s impossible to explain everything indepth clearly nor do I have the expertise/knowledge to do so, there are likely gaps or subtle errors &ndash; but I&rsquo;ll try. Bonus helpful concepts for a google search/chatGPT (but not critical):</p><ul><li>What is the BEAM? What is the erlang runtime system?</li><li>What is garbage collection?</li><li>Scheduling - how does a runtime handle IO? what&rsquo;s a syscall?</li><li>Atomics/Compare & Swap/Test & Set, what is a critical section?</li><li>What is a CPU Register/cache line movement?</li><li>uniprocessors vs multiprocessors(SMP/MIMD)?</li></ul><p>You&rsquo;ve been warned! Grab a coffee or tea and let&rsquo;s scope it out! I&rsquo;ll be using a mixture of go/rust for the examples.</p><h2 id=shaping-performance-constraints>Shaping performance constraints</h2><p>Before we get into the bells and whistles of it all, what are we <em>really</em> trying to achieve? Conceputally a key-value store is simple.
What you want is an abstract interface that can store data and retrieve it fast, essentially a map/dictionary/associative array abstract data type:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Table</span><span class=p>[</span><span class=nx>Key</span> <span class=nx>comparable</span><span class=p>,</span> <span class=nx>Value</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Read</span><span class=p>(</span><span class=nx>Key</span><span class=p>)</span> <span class=p>(</span><span class=nx>Value</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>Write</span><span class=p>(</span><span class=nx>Key</span><span class=p>,</span> <span class=nx>Value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>Delete</span><span class=p>(</span><span class=nx>Key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>In</span><span class=p>(</span><span class=nx>Key</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and you might be thinking why not just throw a hashmap underneath and that works! Infact hashmaps are ubiquitious and contain excellent
properties, however most implementations in standard libraries are not thread safe. CPU cores need to synchronize data access to avoid corrupting data or reading inconsistent or stale data.</p><p>In rust - sharing an <code>std::collections::hash_map::HashMap</code> requires wrapping it in two things:</p><ol><li>an atomic reference count <code>Arc&lt;T></code></li><li>a mutex or some other sync mechanism because the type does not impl <code>Send</code> & <code>Sync</code></li></ol><p>If your data only has to exist within a single thread that&rsquo;s great, but applications tend to need to handle <em>concurrent</em> data access.
Practical examples of this are caches, rate limiting middleware, session storage, distributed config, simple message queues etc</p><p>Let&rsquo;s wrap it in a mutex from std lib&rsquo;s <code>sync</code> package:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Map</span><span class=p>[</span><span class=nx>K</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>V</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl> <span class=nx>Data</span> <span class=kd>map</span><span class=p>[</span><span class=nx>K</span><span class=p>]</span><span class=nx>V</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To <code>Read</code> and <code>Write</code> we must acquire <code>*Map.Lock()</code> and release <code>*Map.Unlock()</code>. This works, up to a point &ndash;
but we can do better! We&rsquo;re trying to build a <em>general purpose</em> data store for
key-value data. Global Mutexes are a good solution but you tend to deal with <em>lock contention</em> on higher values of R/W data access,
especially where your hardware allows parallel access when the underlying memory region&rsquo;s slots are partioned due to hashing across independent regions.</p><p>A clever way of getting around this is by using an advanced concurrency technique called fine-grained locking, the general idea is instead of a global mutex we serialise access to specific partitions[1]:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Map</span> <span class=p>[</span><span class=nx>K</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>V</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>Data</span>  <span class=kd>map</span><span class=p>[</span><span class=nx>K</span><span class=p>]</span><span class=nx>V</span>
</span></span><span class=line><span class=cl> <span class=nx>locks</span> <span class=p>[]</span><span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl> <span class=nx>global</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This is much more complex but can be more write performant but suffer slighly slower reads. The bottleneck of mutexes and serialisation is the reason databases like postgres and mysql have Multi Version Concurrency Control(MVCC) semantics for pushing reads and writes further using transactions. We&rsquo;ll come back to exploring this concept and its tradeoffs.</p><p>Next, we&rsquo;d like to be able to store both ordered and unordered key value data, hash maps store unordered data so this calls for some sort of additional data structure with fast ordered abstract Map operations. We must redefine our interface, depending on our needs, we&rsquo;ll want different abstract properties:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OrderTable</span><span class=p>[</span><span class=nx>Key</span> <span class=nx>cmp</span><span class=p>.</span><span class=nx>Ordered</span><span class=p>,</span> <span class=nx>Value</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nf>Get</span><span class=p>(</span><span class=nx>Key</span><span class=p>)</span> <span class=p>(</span><span class=nx>Value</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nf>Put</span><span class=p>(</span><span class=nx>Key</span><span class=p>,</span> <span class=nx>Value</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nf>Del</span><span class=p>(</span><span class=nx>Key</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nf>In</span><span class=p>(</span><span class=nx>Key</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>For a concrete implementation, let&rsquo;s start with the conceptually simplest/fastest* the Binary Search Tree and a global RWMutex:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>BST</span><span class=p>[</span><span class=nx>Key</span> <span class=nx>cmp</span><span class=p>.</span><span class=nx>Ordered</span><span class=p>,</span> <span class=nx>Value</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>key</span>   <span class=nx>Key</span>
</span></span><span class=line><span class=cl> <span class=nx>value</span> <span class=nx>any</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=nx>parent</span> <span class=o>*</span><span class=nx>BST</span><span class=p>[</span><span class=nx>Key</span><span class=p>,</span> <span class=nx>Value</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=nx>left</span>   <span class=o>*</span><span class=nx>BST</span><span class=p>[</span><span class=nx>Key</span><span class=p>,</span> <span class=nx>Value</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=nx>right</span>  <span class=o>*</span><span class=nx>BST</span><span class=p>[</span><span class=nx>Key</span><span class=p>,</span> <span class=nx>Value</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=nx>global</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Search trees are the &ldquo;go to&rdquo; structure for keeping performant ordered data with balanced read/write performance, by ensuring we keep the &ldquo;search property&rdquo; we can perform on average operations in O(logN) &ndash; if the tree is balanced. Sadly they&rsquo;re bounded by the worst time-complexity of O(h) where h is the height of the tree. What that means is if we get unlucky
with the data - searches can devolve into searching a linked-list. That wouldn&rsquo;t do. Here there are many flavors thankfully.</p><p>Fan favorites include the classics; an AVL Tree, B-Tree or perhaps an LSM Tree, which all come with spices and even more variety.</p><p>In practice we are concerned about much more than order of magnitude choices, we are also interested in how these structures
layout in memory, are the leaves holding a page cache? - there&rsquo;s a fundamental difference between sorting data that can fit in main memory (internal) and
sorting data that exists on disk(external), what kind of concurrent access patterns are enabled? how do they map to our eventual high level API?</p><p>This is where conceptually we take a different road from what exists in the current erlang runtime system. The data structure chosen previously of which we&rsquo;ll be benchmarking against is something called a Contention Adapting Tree [2]. Briefly a CA Tree, dynamically at runtime changes the behaviour and number of locks it holds across the tables it protects depending on nature of contention.</p><p>What are we finally choosing to implement, why?</p><h2 id=the-dumpster-fire-that-is-garbage-collection>The dumpster fire that is garbage collection</h2><p>So far we haven&rsquo;t really had to worry about garbage collection. A brief mention of rust mentioned using atomic reference counts, and in go where this operation
is automatic and opaque to the user we didn&rsquo;t have to worry about it. The resource allocation strategy is tightly coupled to the programming language and environment
we intend our concrete key value implementation to eventually live, so at this point we bid farewall to go and carry on with the intricacies of
low-level memory management.</p><h2 id=a-detour-for-just-enough-web-assembly>A detour for just enough web assembly</h2><p>tdlr; crash course in just enough webassembly</p><h2 id=concurrency-correctness--going-web-scale---are-you-acid-compliant->Concurrency, Correctness & Going web scale - are you ACID compliant? üëÆ</h2><p>These days are you a serious software craftsman <a href="https://www.youtube.com/watch?v=b2F-DItXtZs">if you&rsquo;re not at web scale?</a>.</p><p>In our undying, unending pursuit to scale systems further and further we spin webs of complexity. <a href="https://www.youtube.com/watch?v=RlwlV4hcBac">Why? who knows, it&rsquo;s provocative.</a></p><p>Let&rsquo;s scale! Previously we mentioned fine-grained locking as a technique that could lead to better write performance but at the cost of complexity and read performance &ndash; a related application of this technique is called &ldquo;sharding&rdquo;. Most databases need to ensure certain guarantees with respect to performance, concurrency and correctness. This is commonly encapsulated with ACID - Atomicity, Consistency, Isolation and Durability. Lucky for us, we can cast away the durability requirement as our data set must fit in working memory.</p><p>That leaves us with:</p><ul><li>Atomicity</li><li>Consistency</li><li>Isolation</li></ul><p>what to be done etc</p><h1 id=gotta-go-fast>Gotta Go Fast</h1><p>at what cost?</p><ul><li>use of lock free data structures/behaviour across reads - concurrent skip list crash course, why?</li></ul><p>intro to lock free techniques[3]</p><h2 id=more-complex-types>More complex Types</h2><ul><li>conformance and integration with/into the firefly runtime</li></ul><p>So far these examples have been somewhat generic but the underlying implementation only allowed simple types a key of type <code>string</code> and a value of <code>int</code>.
This is intentionally done in order not to distract from other concepts, but if we really want a general key value store we need to allow many types.
In this case we want to allow every type supported by the erlang runtime systems.</p><h2 id=the-query-parser>The query parser</h2><p>Every good database needs ergonimics features fo good querying! SQL is amazing but is insanely complex to implement and tightly coupled to transaction semantics,
however we don&rsquo;t want to feel left out, let&rsquo;s build a tiny(compared to sql) query syntax and engine.</p><h2 id=testing--benchmarks>Testing & Benchmarks</h2><ul><li>unit testing challenges, tight coupling etc</li><li>conformance with the upstream erts(erlang runtime system) ETS public api and behaviour</li><li>100% erts TEST SUITE coverage</li></ul><p>methodology, coverage, tools, loom, address sanitizer etc insert graphs of benchmark results</p><h2 id=references>References</h2><ul><li>[1] <a href=http://doi.acm.org/10.1145/2505305.2505308>On the scalability of the Erlang term storage</a></li><li>[2] <a href=https://doi.org/10.1145/2633448.2633455>More Scalable Ordered Set for ETS Using Adaptation</a></li><li>[3] <a href="https://learn.microsoft.com/en-gb/windows/win32/dxtecharts/lockless-programming?redirectedfrom=MSDN">Lockless Programming Considerations for Xbox 360 and Windows</a></li></ul><h2 id=whats-a-mutex-really-its-just-a-sephamore>What&rsquo;s a Mutex really it&rsquo;s just a sephamore</h2><p>In a reader-writer lock, a read acquisition has to be visible to
writers, so they can wait for the reads to finish before succeeding to take a write lock. One way to implement this is to have
a shared counter that is incremented and decremented atomically
when reading threads are entering and exiting their critical section.</p></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>source</a>
Copyright ¬© 2024 Haile Lagi<div id=sign-key><span>GPG key ID: 0298F4203ADC85E8</span></div><div id=sign-key><span>Alternatively: 78AEE2846F9B1E1E</span></div></footer></body></html>