<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel="shortcut icon" href=https://www.hailelagi.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Making a Tsunami</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/roadmap title=roadmap>roadmap</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Making a Tsunami</h1><time>December 23, 2023</time></header><p>WIP public draft, come back later. <a href=https://github.com/hailelagi/wavl-ets>https://github.com/hailelagi/wavl-ets</a></p><h1 id=introduction>Introduction</h1><p>This was one of the first really hard ambitious things I tried to build, but sadly because of
either a lack time, grit or knowledge/skill I just couldn&rsquo;t make meaningful progress.</p><p>To be fair - at first it <em>seemed</em> like a simple &ldquo;good first issue&rdquo; kind of thing I had no idea what I was opting into, so here&rsquo;s a disclaimer!
We&rsquo;re going to build a type of database! No It&rsquo;s not enough machinery akin to say postgres but there&rsquo;s a fair bit of stuff going on!</p><p>Give or take some of the outline:</p><ul><li>some knowledge of programming - you&rsquo;ve built a crud app</li><li>an idea of rust&rsquo;s ownership system or exposure to some memory management ala C, C++ or Zig.</li><li>a rough sense of lexical parsing</li><li>some idea about trees and or graph traversal in general</li><li>some concurrency (shared state or message passing)</li><li>Garbage collection in a managed runtime</li><li>Scheduling - how does a runtime handle busy CPU/IO?</li></ul><p>Bonus(but not important):</p><ul><li>Atomics/Compare & Swap</li><li>Some exposure to the CPU Cache/cache line movement</li><li>Some knowledge of the BEAM - elixir or erlang (especially :ets)</li><li>Some knowledge of go&rsquo;s syntax/semantics</li></ul><p>You&rsquo;ve been warned! Grab a coffee or tea and let&rsquo;s scope it out! I&rsquo;ll be using a mixture of go/rust for the examples.</p><h2 id=experimenting-and-shaping-performance-constraints>Experimenting and shaping performance constraints</h2><p>Before we get into the bells and whistles of it all, what are we <em>really</em> trying to achieve? Conceputally a k-v store is simple.
What you want is to first build an interface that can store k/v paired data in-memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Store</span><span class=p>[</span><span class=nx>Key</span> <span class=nx>comparable</span><span class=p>,</span> <span class=nx>Value</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Read</span><span class=p>(</span><span class=nx>Key</span><span class=p>)</span> <span class=p>(</span><span class=nx>Value</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>Write</span><span class=p>(</span><span class=nx>Key</span><span class=p>,</span> <span class=nx>Value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>Delete</span><span class=p>(</span><span class=nx>Key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>In</span><span class=p>(</span><span class=nx>Key</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and you might be thinking why not just throw a hashmap/associate array underneath and that works! If your data access only has to exist
with a single thread that&rsquo;s great, but applications tend to need to handle many <em>concurrent</em> requests - I know! let&rsquo;s wrap it
in a mutex and because I know my read access skews higher than writes maybe I can geta way with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>LockingMap</span><span class=p>[</span><span class=nx>K</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>V</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl> <span class=nx>Fields</span> <span class=kd>map</span><span class=p>[</span><span class=nx>K</span><span class=p>]</span><span class=nx>V</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>LockingMap</span><span class=p>[</span><span class=kt>string</span><span class=p>,</span> <span class=nx>any</span><span class=p>])</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>any</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>l</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>defer</span> <span class=nx>l</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>value</span><span class=p>,</span> <span class=nx>found</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>Fields</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>!</span><span class=nx>found</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>value</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;not found&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>value</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>LockingMap</span><span class=p>[</span><span class=kt>string</span><span class=p>,</span> <span class=nx>any</span><span class=p>])</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>value</span> <span class=nx>any</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>l</span><span class=p>.</span><span class=nx>RWMutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>defer</span> <span class=nx>l</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>l</span><span class=p>.</span><span class=nx>Fields</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>value</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This works, up to a point &ndash; but we can do better! We&rsquo;re trying to build a <em>general purpose</em> data store for
key-value data. Mutexes are a good solution but you tend to deal with <em>lock contention</em> on higher values of R/W data access.</p><p>This won&rsquo;t do at all! This is the reason databases like postgres and mysql have Multi Version Concurrency Control(MVCC) for accessing data -
another thing - is a hashmap the optimal data structure? Lots of research has gone into (and still goes into this topic!) but if were laying out a data structure for querying data on disk the options seem to be B-Tree(variants) and recently an LSM Tree(variants).</p><p>However we don&rsquo;t have to contend with the complexity of <code>fsync</code> and durable storage, therefore we can choose a different structure.
Notably we&rsquo;d like to store both ordered and unordered key value data and this calls for some sort of self balancing data structure.</p><p>Let&rsquo;s go with the conceptually simplest on the Binary Search Tree:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>BST</span><span class=p>[</span><span class=nx>K</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>V</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// todo
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=scopegoals>Scope/Goals</h2><ul><li>conformance with the upstream erts(erlang runtime system) ETS public api and behaviour</li><li>100% erts TEST SUITE coverage</li><li>use of lock free data structures/behaviour across reads</li><li>conformance and integration with/into the firefly runtime</li></ul></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>source</a>
Copyright © 2023 Haile Lagi<div id=sign-key><span>GPG key ID: 0298F4203ADC85E8</span></div><div id=sign-key><span>Alternatively: 78AEE2846F9B1E1E</span></div></footer></body></html>