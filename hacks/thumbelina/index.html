<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel="shortcut icon" href=https://www.hailelagi.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Thumbelina</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (·àê·ã≠·àå)</a></h2><nav><ul><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/roadmap title=roadmap>roadmap</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Thumbelina</h1><time>December 20, 2023</time></header><p>Re-re-re-introducing <a href=https://github.com/hailelagi/thumbelina>thumbelina</a> ‚öóÔ∏èüß™üîÆ.</p><p>Thumbelina was a project I started thinking about sometime in late 2022 when I was a wee little inexperienced with elixir. The problem I set out to solve was simple, I wanted to manipulate images using elixir, specifically I wanted to generate thumbnails. Seems straightfoward no?</p><p>As it turns out this is the kind of thing the language isn&rsquo;t suited for &ndash; most practical roads lead to aws s3 and
adding imagemagick to your dockerfile. For production that is exactly what I did, but I kept wondering what was the &ldquo;best&rdquo; solution?</p><p>I stumbled upon reading about discord&rsquo;s <a href=https://discord.com/blog/using-rust-to-scale-elixir-for-11-million-concurrent-users>SortedSet</a> and so began my journey to challenge myself by learning (async) rust, rustler, some systems concepts and tinkering with extending and interfacing with BEAM internals.</p><p>Time flies by, off and on whenever I&rsquo;d get bored in my free time I&rsquo;d incrementally built out small parts of the library that does image processing &ndash; but I never finished it&mldr;until now.</p><p><strong>What was the outcome?</strong></p><p><em>It was/is a bad idea</em>:</p><ul><li><p>Image manipulation means crossing the FFI boundary by calling a subroutine in a different address space - this has a cost, serialising data between this boundary also has a cost, getting the two things to be happy together is non-obvious and there are much simpler ways to efficiently solve this.</p></li><li><p>Image compression, there&rsquo;s very little benefit to doing so on images. To quote the peformance README section of snappy(the underlying compression algorithm used here):</p></li></ul><blockquote><p>Typical compression ratios (based on the benchmark suite) are about 1.5-1.7x for plain text, about 2-4x for HTML, and of course 1.0x for JPEGs, PNGs and other already-compressed data.</p></blockquote><p>As it turns out popular binary formats like .png, .jpeg and vectorized formats like .svg are fairly optimized. Who knew? not me. I felt really dumb reading that.</p><p>If you&rsquo;d like to learn <em>how</em> to do it anyway read on!</p><h3 id=boring-high-level-concepts>Boring High Level Concepts</h3><p>One approach to using programs written in other languages is opening a <code>Port</code>, mogrify an elixir ImageMagick wrapper for example leverages <code>System.cmd</code>,
which uses a unix pipe to communicate with the ImageMagick binary via streams of bytes in a different OS process. There are other high level libraries that make this a viable practical approach.</p><p>Or to use a similar mechanism and implement the functionality yourself plugging into the VM,
known as &ldquo;linked-in drivers&rdquo; or as a &ldquo;hidden node&rdquo; via a network pipe such as a TCP socket, the advantage of doing this is you get fault tolerant mechanisms like supervisors. The second node can be in go, rust or elixir itself. The job scheduler Oban has a way to send workers over to other servers too if you don&rsquo;t wanna manage the networking yourself or want a db intermediary. You can mix and match. This is a good overview of the <a href=https://www.theerlangelist.com/article/outside_elixir>solution space</a>.</p><p>I used the Natively Implemented Function(NIF) C ABI. This is a managed space outside the BEAM ie rustler
which implements this binary interface and provides high level types in lovely rust.</p><h3 id=in-the-weeds>In the Weeds</h3><p>These subroutines are expected to be pre-emptively scheduled in &lt;1ms and are appropriate for <code>synchronous</code> operations such as short CPU burst computations and custom data structures, you don&rsquo;t want to copy around the runtime ala sorted set, so we don&rsquo;t wait but exit early, here&rsquo;s how making a thumbnail works:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=c1># you can also read the binary from a network</span>
</span></span><span class=line><span class=cl><span class=c1># but let&#39;s keep it simple by reading from disk</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=ss>:ok</span><span class=p>,</span> <span class=n>image</span><span class=p>}</span> <span class=o>=</span> <span class=nc>Thumbelina</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=s2>&#34;./path_to_image.jpg&#34;</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=n>width</span> <span class=o>=</span> <span class=mf>50.0</span>
</span></span><span class=line><span class=cl><span class=n>height</span> <span class=o>=</span> <span class=mf>50.0</span>
</span></span><span class=line><span class=cl><span class=n>destination</span> <span class=o>=</span> <span class=n>self</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nc>Thumbelina.Internal</span><span class=o>.</span><span class=n>cast</span><span class=p>(</span><span class=ss>:thumbnail</span><span class=p>,</span> <span class=n>destination</span><span class=p>,</span> <span class=n>image</span><span class=o>.</span><span class=n>bytes</span><span class=p>,</span> <span class=n>image</span><span class=o>.</span><span class=n>extension</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=ss>:ok</span>
</span></span></code></pre></div><p>This near instantly returns. Tokio first lazily inits on a single worker thread:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>static</span><span class=w> </span><span class=no>TOKIO</span>: <span class=nc>Lazy</span><span class=o>&lt;</span><span class=n>Runtime</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Lazy</span>::<span class=n>new</span><span class=p>(</span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Builder</span>::<span class=n>new_multi_thread</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>worker_threads</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>build</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Thumbelina.Internal - no runtime!&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span></code></pre></div><p>now we can start scheduling on the first invocation of this subroutine since there is no <code>main</code> <a href=https://tokio.rs/tokio/topics/bridging>macro to expand</a> in this binary, this is afterall an embed that&rsquo;s <a href=https://www.erlang.org/doc/tutorial/nif.html>dynamically linked</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Asynchronously spawn a green thread on one physical thread
</span></span></span><span class=line><span class=cl><span class=c1>// that&#39;s to be managed on the tokio runtime.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>spawn</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>task</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>JoinHandle</span><span class=o>&lt;</span><span class=n>T</span>::<span class=n>Output</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>T</span>: <span class=nc>Future</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>T</span>::<span class=n>Output</span>: <span class=nb>Send</span> <span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=no>TOKIO</span><span class=p>.</span><span class=n>spawn</span><span class=p>(</span><span class=n>task</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>It gets busy in a seperate OS thread space unbeknownst to the BEAM and sends a message when it&rsquo;s done to <code>destination</code> with a result, note that you can
also do this without tokio with <a href=https://docs.rs/rustler/latest/rustler/thread/struct.ThreadSpawner.html>operating system threads</a>, the worker looks like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// move ownership of the smart pointer to the image binary 
</span></span></span><span class=line><span class=cl><span class=c1>// outside the lifetime of the NIF sync call
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>buffer</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>binary</span><span class=p>.</span><span class=n>to_owned</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>buffered_lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>new</span><span class=p>(</span><span class=n>RwLock</span>::<span class=n>new</span><span class=p>(</span><span class=n>buffer</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>task</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffered_lock</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buffer</span><span class=p>.</span><span class=n>read</span><span class=p>().</span><span class=n>unwrap</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>operation</span>::<span class=n>perform</span><span class=p>(</span><span class=n>operation</span><span class=p>,</span><span class=w> </span><span class=n>width</span><span class=p>,</span><span class=w> </span><span class=n>height</span><span class=p>,</span><span class=w> </span><span class=n>extension</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>image</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>env</span><span class=p>.</span><span class=n>send_and_clear</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pid</span><span class=p>,</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>env</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Success</span><span class=w> </span><span class=p>{</span><span class=n>op</span>: <span class=nc>thumbelina</span>::<span class=n>atoms</span>::<span class=n>ok</span><span class=p>(),</span><span class=w> </span><span class=n>result</span><span class=p>}</span><span class=w> </span><span class=p>.</span><span class=n>encode</span><span class=p>(</span><span class=n>env</span><span class=p>)})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>in our local process which is <code>self()</code> here we should eventually get:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=k>receive</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span><span class=ss>:ok</span><span class=p>,</span> <span class=n>result</span><span class=p>}</span> <span class=o>-&gt;</span> <span class=nc>IO</span><span class=o>.</span><span class=n>inspect</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>The magic of the BEAM is really in easy distributed networking, say we try to send over our <code>destination</code> as the pid of a process on a remote server &ndash; this seems possible because elixir/erlang has <a href=https://livebook.manning.com/book/erlang-and-otp-in-action/chapter-8/>location transparency of pids/processes</a>. However the NIF ABI is tightly coupled to the internals of the host&rsquo;s runtime and behaviour and therefore only allows <code>LocalPid</code>. However it&rsquo;s entirely possible to rebroadcast the result of this operation in a genserver.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=nc>GenServer</span><span class=o>.</span><span class=n>start_link</span><span class=p>(</span><span class=n>__MODULE__</span><span class=p>,</span> <span class=p>[],</span> <span class=ss>name</span><span class=p>:</span> <span class=p>{</span><span class=ss>:global</span><span class=p>,</span> <span class=n>__MODULE__</span><span class=p>})</span>
</span></span></code></pre></div><p>This idea can perhaps be expanded on, maybe you want to model this in a
producer-consumer pipeline? using GenStage?</p><pre tabindex=0><code>[A] -&gt; [B] -&gt; [C]

A producer continually ingests data from data lake 
B producer consumer (process thumbnail using message passing)
C consumer await result out do stuff with output
</code></pre><p>You may be wondering doesn&rsquo;t reading entire large bytes of images into memory lead to sudden spikes in memory?
You&rsquo;re right. I considered providing a stream/yeilding between the runtime and the C ABI but the <a href=https://github.com/hailelagi/thumbelina/pull/10>cost/benefit doesn&rsquo;t seem worth it</a>.</p><p>In theory by inheriting the complexity of owning such a system end to end you can really tune peformance by mixing and matching cool features. BEAM
for simple concurrency and distributed networking and rust for it&rsquo;s type system, low-level memory safety and speed. This is still true, but in practice this
idea falls flat. The most value in this domain from being able to re-use bindings to highly optimised C/Rust libraries like <a href=https://github.com/akash-akya/vix>Vix</a>.</p><h3 id=going-forward>Going forward</h3><p>I&rsquo;m not sure I&rsquo;m going to continue to expand on this idea, and will mostly be moving on. A nod to projects I think
are interesting applications/usecases in the wild:</p><ol><li><a href=https://github.com/tessi/wasmex>wasmex</a> - which provides a low-level interface to wasm/wasi via wasmtime.</li><li><a href=https://github.com/elixir-explorer/explorer>explorer</a> which brings dataframe processing to elixir via polar-rs.</li><li><a href=https://github.com/rbino/tigerbeetlex>Tigerbeetlex</a> a database client, it&rsquo;s
pretty much the same ideas explained here but is written in zig, handles interacting with the C binary ABI
and implements the <a href=https://tigerbeetle.com/>TigerBeetle</a> client spec by embedding the Zig client.</li></ol></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>source</a>
Copyright ¬© 2024 Haile Lagi<div id=sign-key><span>GPG key ID: 0298F4203ADC85E8</span></div></footer></body></html>