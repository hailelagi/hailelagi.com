<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel="shortcut icon" href=https://www.hailelagi.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Thumbelina</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile Lagi</a></h2><nav><ul><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href="https://app.zerion.io/0x3430b8b776c531e01736ddfc15b11d9e14afe793/overview?name=haile.eth" title=portfolio>portfolio</a></li><li><a href=/readme title=readme>readme</a></li><li><a href=/resume title=resume>resume</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Thumbelina</h1><time>September 7, 2022</time></header><p>This is my first entry in a new series called &ldquo;hacks&rdquo;. Technical demos for the random junk I build.
Thumbelina is an experiment in <em>extending</em> elixir.</p><blockquote><p>Rust backed erlang NIF for image processing.</p><p>&ndash; <a href=https://github.com/hailelagi/thumbelina/blob/main/README.md>thumbelina&rsquo;s readme</a></p></blockquote><p>Thumbelina tries to be a lazy, <del>distributed</del>, data-pipeline processor library.</p><p>The most popular example of this kind of library(NIF) is discord&rsquo;s
<a href=https://github.com/discord/sorted_set_nif>SortedSet</a>, the
<a href=https://discord.com/blog/using-rust-to-scale-elixir-for-11-million-concurrent-users>blog post</a>
is also an excellent resource for the curious, although it extends elixir/erlang in a different way, improving
mutable shared data access/writes across processes. See features/demo for production ready libraries that target a
similar feature set.</p><h3 id=mechanisms>Mechanisms</h3><p>One approach to using programs written in other languages is opening a <code>Port</code>, mogrify for example leverages <code>System.cmd</code>,
which uses a unix pipe to communicate with the ImageMagick binary via streams of bytes.</p><p>Or to use the same mechanism and implement the functionality yourself in C/C++ and (de)serialize, running in the VM,
known as &ldquo;linked-in drivers&rdquo; or as a &ldquo;hidden node&rdquo; via a network pipe such as a TCP socket.</p><p>If you&rsquo;re generally interested in how to do this yourself, this is a <a href=https://www.theerlangelist.com/article/outside_elixir>great introduction</a>.</p><h3 id=overview>Overview</h3><p>A Natively Implemented Function(NIF) however runs in a scheduler thread in the BEAM by default, these are expected to be
pre-emptively scheduled quickly and are appropriate for <code>synchronous</code> operations such as short performance sensitive
computations and custom data structures. Implementing a NIF is a little dangerous, see the <code>README.md</code>
for details on pitfalls.</p><p>Getting this right at the systems level, requires providing custom concurrency synchronisation and yielding!</p><p>Thumbelina uses a yielding mechanism by default implemented in the beam, for data beyond a specified limit or where the
image bytes cannot be chunked, a dirty NIF thread is spawned to handle CPU bound processing.</p><h3 id=featuresdemo>Features/Demo</h3><p>phoenix server - <a href=https://thumbelina.fly.dev/>https://thumbelina.fly.dev/</a></p><p>Thumbelina can be used to run a <a href=https://fly.io/docs/app-guides/run-a-global-image-service/>distributed global image service</a>,
cluster with elixir, underneath it uses <code>image-rs</code>, if trying to run in production consider alternative libraries like:</p><ul><li><a href=https://github.com/h2non/imaginary>https://github.com/h2non/imaginary</a></li><li><a href=https://github.com/imazen/imageflow>https://github.com/imazen/imageflow</a> (with the elixir binding)</li><li><a href=https://github.com/akash-akya/vix>https://github.com/akash-akya/vix</a></li></ul><p>Elixir/Erlang gives you superpowers when it comes to distributed workloads, giving you access to incredible abstractions
that would simply be either too hard or take too long to implement in any other language.</p><h3 id=going-foward>Going foward</h3><p>Eventually it is likely possible to distribute the workload across erlang/elixir nodes. If you&rsquo;ve found a bug,
or this is something you&rsquo;d like to see please open an <a href=https://github.com/hailelagi/thumbelina/issues>issue ;)</a>.</p></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>source</a>
Copyright Â© 2022 Haile Lagi</footer></body></html>