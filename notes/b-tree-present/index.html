<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel="shortcut icon" href=https://www.hailelagi.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Database Internals: B Tree Basics - Slides</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href=/bookshelf title=bookshelf>bookshelf</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=notes>notes</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Database Internals: B Tree Basics - Slides</h1><time>March 3, 2024</time></header><p>generated with: <a href=https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html>https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a>, please feel free to explore!</p><h1 id=a-simple-2-way-b-tree>A simple 2-way B+ tree</h1><p>assumptions:</p><ul><li><em>non-decreasing order</em> and <em>max degree</em> of 3</li><li>elements(N) are 1, 2, 3, 4, 5</li><li>**sibling pointers (B-link borrowed)</li></ul><h2 id=insertion>Insertion</h2><p>Inserting, find target leaf and insert the keys <code>1</code> and <code>2</code> target == root.</p><p><strong>[figure 1]</strong>
<img src=/init.png alt=init></p><p>When we insert key <code>3</code>? we have our first <em>overflow</em> causing a split:
<img src=/split.png alt=split>
<code>2</code> is <em>promoted</em> and contents are split in two, we recurse from the bottom up.</p><p><strong>[figure 2]</strong>
What if we add key <code>4</code> our tree looks weird doesn&rsquo;t it:
<img src=/balance.png alt=balance></p><p>and now have to &ldquo;rebalance&rdquo; our tree with incoming key <code>5</code>:</p><p><strong>[figure 3]</strong>
<img src=/rebalance.png alt=rebalance></p><h2 id=search>Search</h2><p>searching is an Olog(N) operation!</p><p>just a reminder this is <em>really powerful</em> if n = 1 billion, dominance:</p><ul><li>lg(n) = 0.030 μs</li><li>f(n) = 1 sec</li><li>nlg(n) = 29.9 sec</li><li>n ** 2 = 31.7 years</li><li>2 ** n = :/</li></ul><p>with a branching factor of 1001 and height 3 can store over one billion keys:
num keys = branching factor ^ height - 1 * branching factor - 1</p><p>point and range queries follow the same logarithmic path.</p><p><strong>[figure 4]</strong>
<img src=/search.png alt=search></p><h2 id=deletion>Deletion</h2><p>Let&rsquo;s remove 4.</p><p>First we find 4 using binary search, then re-arrange our pointers and rebalance:
<strong>[figure 5]</strong>
<img src=/delete.png alt=delete></p><p>Rebalancing involves restoring our ordered structure and keeping pointers valid and
performing a merge or (*redistribution.)</p></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>source</a>
Copyright © 2024 Haile Lagi<div id=sign-key><span>GPG key ID: 0298F4203ADC85E8</span></div></footer></body></html>