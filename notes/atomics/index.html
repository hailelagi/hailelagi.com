<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=‚Äùog:title‚Äù content="Atomics | Haile (·àê·ã≠·àå)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Atomics | Haile (·àê·ã≠·àå)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>Atomics</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (·àê·ã≠·àå)</a></h2><nav><ul><li><a href=/bookshelf title=bookshelf>bookshelf</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=writing>writing</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Atomics</h1><time>November 26, 2024</time><meta name=twitter:card content="summary">
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><div class=callout-warning>üí°
This initial draft was to make some notes while reading marabos' atomics and locks,
and somehow transmogrify key concepts, distilling yet and perhaps wrapping it into a case study of
some sort, perhaps `WTF::parking_lot` or my own lock-free linked-list, sadly, although it does not meet any standards of quality or
comprehension, here it is, anyway, otherwise it may never escape my drafts.</div><p>Atomics, typically a compiler intrinsic, platform/hardware dependent(x86, risc-v, arm etc), OS dependent.
typically at least a pointer size &ndash; in rust a <a href=https://doc.rust-lang.org/std/primitive.usize.html><code>usize</code></a></p><h2 id=usecasespatterns>Usecases/Patterns</h2><ul><li>stop flag/locking primitive/aka naive mutex + busy wait</li><li>thread progress reporting</li><li>synchronization/barrier/fence etc</li><li>lazy initialization</li></ul><h2 id=orderings>Orderings</h2><ul><li>Relaxed: total modification order</li><li>Release & Acquire: happens-before btw thread A & B</li><li>AcqRel, SeqCst:</li><li>*Consume</li></ul><blockquote><p>A happens-before relationship is formed when an acquire-load operation observes the result of a release-store operation. In this case, the store and everything before it, happened before the load and everything after it.</p></blockquote><ul><li>go mem: <a href=https://research.swtch.com/gomm>https://research.swtch.com/gomm</a></li><li>overview: <a href=https://doc.rust-lang.org/nightly/nomicon/atomics.html>https://doc.rust-lang.org/nightly/nomicon/atomics.html</a></li><li>super helpful summary(formalism): <a href=https://gist.github.com/kprotty/bb26b963441baf2ab3486a07fbf4762e>https://gist.github.com/kprotty/bb26b963441baf2ab3486a07fbf4762e</a></li><li>c++ mem: <a href=https://en.cppreference.com/w/cpp/atomic/memory_order>https://en.cppreference.com/w/cpp/atomic/memory_order</a></li></ul><h2 id=load-and-store>Load and Store</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>AtomicI32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>load</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>store</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Building a lock with load/store:</p><blockquote><p>As you can see from this interleaving, with timely (untimely?) interrupts, we can easily produce a case where both threads set the flag to 1 and both threads are thus able to enter the critical section. This behavior is what professionals call ‚Äúbad‚Äù ‚Äì we have obviously failed to provide the most basic requirement: providing mutual exclusion.</p></blockquote><blockquote><p>The performance problem, which we will address more later on, is the fact that the way a thread waits to acquire a lock that is already held: it endlessly checks the value of flag, a technique known as spin-waiting. Spin-waiting wastes time waiting for another thread to release a lock. The waste is exceptionally high on a uniprocessor, where the thread that the waiter is waiting for cannot even run (at least, until a context switch oc- curs)! Thus, as we move forward and develop more sophisticated solu- tions, we should also consider ways to avoid this kind of waste.</p></blockquote><h2 id=fetch-and-modify-test-and-set-fetch-add-etc>Fetch and Modify (test-and-set, fetch-add, etc)</h2><ul><li>can impose &lsquo;ordering&rsquo; of a &lsquo;happens before&rsquo;</li><li>viz can make a binary mutex</li><li>can determine thread progress</li><li>statistics</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>AtomicI32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>fetch_add</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>v</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>fetch_sub</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>v</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>fetch_or</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>v</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>fetch_and</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>v</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>fetch_nand</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>v</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>fetch_xor</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>v</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>fetch_max</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>v</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>fetch_min</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>v</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>swap</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>v</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>ordering</span>: <span class=nc>Ordering</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w> </span><span class=c1>// &#34;fetch_store&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=compare-and-swapcompare-and-exchange>Compare and Swap/Compare and Exchange</h2><p>CAS is a super flexible primitive, can build most things out of it. ABA problem bites you though,
via logical vs physical &ldquo;happens-before&rdquo;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>AtomicI32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>compare_exchange</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>expected</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>new</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// In reality, the load, comparison and store,
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// all happen as a single atomic operation.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>load</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>expected</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Value is as expected.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=c1>// Replace it and report success.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>new</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Ok</span><span class=p>(</span><span class=n>v</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// The value was not as expected.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=c1>// Leave it untouched and report failure.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=n>v</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Monotonic Counter, weak ordering:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>increment</span><span class=p>(</span><span class=n>a</span>: <span class=kp>&amp;</span><span class=nc>AtomicU32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>current</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>Relaxed</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>new</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>current</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=n>current</span><span class=p>,</span><span class=w> </span><span class=n>new</span><span class=p>,</span><span class=w> </span><span class=n>Relaxed</span><span class=p>,</span><span class=w> </span><span class=n>Relaxed</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Ok</span><span class=p>(</span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>current</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=locks---mutexes-rwlock-etc>Locks - Mutexes/ RwLock etc</h2><p>design axis:</p><ul><li>fairness (FIFO)</li><li>correctness (mutual exlusion)</li><li>performance (syscall overhead, space etc)</li><li>priority inversion</li></ul><p>mutex lock/unlock atomic:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>atomic</span>::<span class=n>AtomicBool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>atomic</span>::<span class=n>Ordering</span>::<span class=p>{</span><span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Relaxed</span><span class=p>,</span><span class=w> </span><span class=n>Release</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>thread</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=no>DATA</span>: <span class=nb>String</span> <span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>static</span><span class=w> </span><span class=no>LOCKED</span>: <span class=nc>AtomicBool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>AtomicBool</span>::<span class=n>new</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>mu</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=no>LOCKED</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Relaxed</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>is_ok</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Safety: We hold the exclusive lock, so nothing else is accessing DATA.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=no>DATA</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=sc>&#39;!&#39;</span><span class=p>)</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=no>LOCKED</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=n>Release</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>Copyright ¬© 2024 Haile Lagi</a><div><span>private inquiries: hailelagi[at]gmail.com</span></div><div><span>or informally(twitter/x): https://x.com/haile_lagi</span></div></footer></body></html>