<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=”og:title” content="DIY an LSM Tree | Haile (ሐይሌ)"><meta name=twitter:card content="summary"><meta name=twitter:title content="DIY an LSM Tree | Haile (ሐይሌ)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>DIY an LSM Tree</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href=/bookshelf title=bookshelf>bookshelf</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=writing>writing</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>DIY an LSM Tree</h1><time>April 22, 2024</time><meta name=twitter:card content="summary">
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><p>day 1 personal notes from LSM in a week, basic components:</p><ul><li>memtable</li><li>SSTable</li><li>WAL</li></ul><h2 id=a-memtable>a memtable</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>MemTable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>map</span>: <span class=nc>Arc</span><span class=o>&lt;</span><span class=n>SkipMap</span><span class=o>&lt;</span><span class=n>Bytes</span><span class=p>,</span><span class=w> </span><span class=n>Bytes</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>wal</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=n>Wal</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>approximate_size</span>: <span class=nc>Arc</span><span class=o>&lt;</span><span class=n>AtomicUsize</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol><li><code>skiplist - </code>crossbeam_skiplist`</li></ol><p>see: <a href=https://github.com/crossbeam-rs/rfcs/blob/master/text/2018-01-14-skiplist.md>https://github.com/crossbeam-rs/rfcs/blob/master/text/2018-01-14-skiplist.md</a></p><blockquote><p>Regarding performance, a skip list is fundamentally disadvantaged compared to a B-tree. Every node in a skip list is separately allocated on the heap, while a B-tree allocates nodes in large blocks, thus greatly improving cache utilization. The problem of scattered skip list nodes in memory can be somewhat mitigated using custom allocators (by trying to allocate adjacent nodes in a skip list as close as possible in memory), but typically with great difficulty and underwhelming results.</p></blockquote><blockquote><p>as soon as we add more threads, contended locking brings a huge penalty on performance.</p></blockquote><blockquote><p>poor memory locality re: skip list</p></blockquote><p>reference counting contiguous slices of memory.
2. Arc&lt;&[u8]> see: <a href=https://github.com/tokio-rs/bytes>https://github.com/tokio-rs/bytes</a></p><blockquote><p>very important !!!
Before it can be flushed, the memtable has to be switched: a new memtable is allocated, and it becomes a target for all new writes, while the old one moves to the flushing state. These two steps have to be performed atomically.
The flushing memtable remains available for reads until its contents are fully flushed. After this, the old memtable is discarded in favor of a newly written disk-resident table, which becomes available for reads.</p></blockquote><p>figuring out the scope for how long what locks should live is tricky&mldr;deadlocking yourself is very easy! overly broad locking is also a bad default mode of thought.</p><blockquote><p>mut memtable -> immutable memtable -> SST what &lsquo;current&rsquo; live read version to serve</p></blockquote><blockquote><p>locking policies/tradeoffs, parking_lot::RwLock uses a task-fair locking policy, which avoids reader and writer starvation, whereas the standard library version makes no guarantees.</p></blockquote><ul><li><a href=https://blog.mozilla.org/nfroyd/2017/03/29/on-mutex-performance-part-1>https://blog.mozilla.org/nfroyd/2017/03/29/on-mutex-performance-part-1</a></li><li><a href=https://cs.stackexchange.com/questions/70125/why-are-most-mutex-implementations-unfair>https://cs.stackexchange.com/questions/70125/why-are-most-mutex-implementations-unfair</a></li><li><a href=https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Mutex_Flavors.html>https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Mutex_Flavors.html</a></li></ul><p>day 2:</p><blockquote><p>Usually, storage engines offer a cursor or an iterator to navigate through file contents. This cursor holds the offset of the last consumed data record, can be checked for whether or not iteration has finished, and can be used to retrieve the next data record.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>MemtableIterator</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>map</span>: <span class=nc>Arc</span><span class=o>&lt;</span><span class=n>SkipMap</span><span class=o>&lt;</span><span class=n>Bytes</span><span class=p>,</span><span class=w> </span><span class=n>Bytes</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>iter</span>: <span class=nc>SkipMapRangeIter</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=interesting-linksmiscellaneous>Interesting links/Miscellaneous</h2><ul><li><a href=https://neon.tech/blog/get-page-at-lsn>https://neon.tech/blog/get-page-at-lsn</a></li><li><a href=https://neon.tech/blog/architecture-decisions-in-neon>https://neon.tech/blog/architecture-decisions-in-neon</a></li></ul></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>Copyright © 2024 Haile Lagi</a><div><span>private inquiries: hailelagi[at]gmail.com</span></div><div><span>or informally(twitter/x): https://x.com/haile_lagi</span></div></footer></body></html>