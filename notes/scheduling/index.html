<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=‚Äùog:title‚Äù content="scheduling stuff -_- | Haile (·àê·ã≠·àå)"><meta name=twitter:card content="summary"><meta name=twitter:title content="scheduling stuff -_- | Haile (·àê·ã≠·àå)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>scheduling stuff -_-</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (·àê·ã≠·àå)</a></h2><nav><ul><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=notes>notes</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>scheduling stuff -_-</h1><time>November 10, 2024</time><meta name=twitter:card content="summary">
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><div class=callout-warning>üí°
how do we schedule tasks in the face of disk and network access?</div><p>design choices:</p><ol><li>cooperative vs pre-emptive</li><li>completion/notify vs polling aka (polling vs interrupt)</li><li>multicore contention/false sharing dilemmas</li><li>work distribution + length of tasks</li></ol><p><strong>blocking(old-school)</strong>:
select/poll sync network file inspect if r/w/err on packets</p><p>non-blocking magic:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>aiocb</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>               <span class=cm>/* The order of these fields is implementation-dependent */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>               <span class=kt>int</span>             <span class=n>aio_fildes</span><span class=p>;</span>     <span class=cm>/* File descriptor */</span>
</span></span><span class=line><span class=cl>               <span class=kt>off_t</span>           <span class=n>aio_offset</span><span class=p>;</span>     <span class=cm>/* File offset */</span>
</span></span><span class=line><span class=cl>               <span class=k>volatile</span> <span class=kt>void</span>  <span class=o>*</span><span class=n>aio_buf</span><span class=p>;</span>        <span class=cm>/* Location of buffer */</span>
</span></span><span class=line><span class=cl>               <span class=kt>size_t</span>          <span class=n>aio_nbytes</span><span class=p>;</span>     <span class=cm>/* Length of transfer */</span>
</span></span><span class=line><span class=cl>               <span class=kt>int</span>             <span class=n>aio_reqprio</span><span class=p>;</span>    <span class=cm>/* Request priority */</span>
</span></span><span class=line><span class=cl>               <span class=k>struct</span> <span class=n>sigevent</span> <span class=n>aio_sigevent</span><span class=p>;</span>   <span class=cm>/* Notification method */</span>
</span></span><span class=line><span class=cl>               <span class=kt>int</span>             <span class=n>aio_lio_opcode</span><span class=p>;</span> <span class=cm>/* Operation to be performed;
</span></span></span><span class=line><span class=cl><span class=cm>                                                  lio_listio() only */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>               <span class=cm>/* Various implementation-internal fields not shown */</span>
</span></span><span class=line><span class=cl>           <span class=p>};</span>
</span></span></code></pre></div><pre tabindex=0><code>man aio
</code></pre><blockquote><p>The existing aio interface is comprised of three main system calls: a system call to setup an aio context (io_setup(2)),
one to submit IO (io_submit(2)), and one to reap or wait for completions of IO (io_getevents(2)). Since a change
in behavior was required for multiple of these system calls, we needed to add new system calls to pass in this
information</p></blockquote><p>see: <a href=https://www.gnu.org/s/libc/manual/html_node/Asynchronous-I_002fO.html>https://www.gnu.org/s/libc/manual/html_node/Asynchronous-I_002fO.html</a>
rust: these calls are made via mio: <a href=https://github.com/tokio-rs/mio>https://github.com/tokio-rs/mio</a>
see: <a href=https://wycats.gitbooks.io/mio-book/content/>https://wycats.gitbooks.io/mio-book/content/</a></p><p>pollers: rust&rsquo;s <code>Future</code>, javascript/libuv viz: epoll, kqueue. completion: io_uring</p><p>popular frameworks:</p><ul><li>single-threaded</li><li>thread-per-core</li><li>work stealing</li></ul><h2 id=event-based-scheduling>event based scheduling</h2><p>event handler, event loop</p><pre tabindex=0><code>run_queue = queue();
s = new StackFrame();

if is != complete + atomic {
    // a suspension must be injected, it is the only opportunity 
    // in a user space scheduler whereas the os can forcibly pre-empt via timers etc
    s.suspend() 
    run_queue.push(s)
}
</code></pre><p>process:</p><pre tabindex=0><code>while (1) {
    events = getEvents();
    for (e in events)
        processEvent(e);
}
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>mio</span>::<span class=p>{</span><span class=n>Events</span><span class=p>,</span><span class=w> </span><span class=n>Poll</span><span class=p>,</span><span class=w> </span><span class=n>Interest</span><span class=p>,</span><span class=w> </span><span class=n>Token</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>mio</span>::<span class=n>net</span>::<span class=n>TcpStream</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>net</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>SocketAddr</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Bind a server socket to connect to.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>addr</span>: <span class=nc>SocketAddr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;127.0.0.1:0&#34;</span><span class=p>.</span><span class=n>parse</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>server</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>net</span>::<span class=n>TcpListener</span>::<span class=n>bind</span><span class=p>(</span><span class=n>addr</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Construct a new `Poll` handle as well as the `Events` we&#39;ll store into
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>poll</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Poll</span>::<span class=n>new</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>events</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Events</span>::<span class=n>with_capacity</span><span class=p>(</span><span class=mi>1024</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Connect the stream
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>stream</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TcpStream</span>::<span class=n>connect</span><span class=p>(</span><span class=n>server</span><span class=p>.</span><span class=n>local_addr</span><span class=p>()</span><span class=o>?</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Register the stream with `Poll`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>poll</span><span class=p>.</span><span class=n>registry</span><span class=p>().</span><span class=n>register</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>stream</span><span class=p>,</span><span class=w> </span><span class=n>Token</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=w> </span><span class=n>Interest</span>::<span class=no>READABLE</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Interest</span>::<span class=no>WRITABLE</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Wait for the socket to become ready. This has to happens in a loop to
</span></span></span><span class=line><span class=cl><span class=c1>// handle spurious wakeups.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>poll</span><span class=p>.</span><span class=n>poll</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>events</span><span class=p>,</span><span class=w> </span><span class=nb>None</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>event</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=o>&amp;</span><span class=n>events</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>event</span><span class=p>.</span><span class=n>token</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>Token</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>event</span><span class=p>.</span><span class=n>is_writable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// The socket connected (probably, it could still be a spurious
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=c1>// wakeup)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Ok</span><span class=p>(());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=problems>Problems</h2><ul><li>multicore requires, multi instances of an event loop + sync mechanisms</li><li>implicit blocking due to page faults is hard to avoid and thus can lead to large performance problems when prevalent.</li><li>semantics of the api</li></ul><h2 id=essential-reading>Essential reading</h2><ul><li><a href=https://kernel.dk/io_uring.pdf>https://kernel.dk/io_uring.pdf</a></li><li><a href=https://unixism.net/loti/>https://unixism.net/loti/</a></li></ul></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>Copyright ¬© 2025 Haile Lagi</a><div><span>feel free to reach out: hailelagi[at]gmail.com</span></span></div></footer></body></html>