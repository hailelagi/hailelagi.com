<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=‚Äùog:title‚Äù content="DIY an on-disk B+ Tree | Haile (·àê·ã≠·àå)"><meta name=twitter:card content="summary"><meta name=twitter:title content="DIY an on-disk B+ Tree | Haile (·àê·ã≠·àå)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>DIY an on-disk B+ Tree</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (·àê·ã≠·àå)</a></h2><nav><ul><li><a href=/bookshelf title=bookshelf>bookshelf</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=writing>writing</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>DIY an on-disk B+ Tree</h1><time>April 17, 2024</time><meta name=twitter:card content="summary">
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><div class=callout-warning>üí°
This article is a <i>speed run/crash course/concise note/summary</i> and assumes the reader has read or is somewhat familiar with concepts explained in part I of database internals. Notably chapter 1 - 4, and parts of chapter 5 where Buffer Management is explained.</div><p>If not, here&rsquo;s a visual crash course on the operations of a <a href=../b-tree-present>b-tree</a> and <a href=../b-tree-talk>generally on-disk considerations.</a> or a much better <a href=https://fly.io/blog/sqlite-internals-btree/>walkthrough with sqlite</a></p><p>What is a Datastructure&rsquo;s memory representation? Everything is either a contigous block or pointer based.
<em>Relevant programming techniques</em>: pointers, recursion and binary search - Olog(N) is powerful, syscalls and binary formats.</p><p>B-Trees are useful for:</p><ol><li>In-memory indexes/&lsquo;index b-trees&rsquo; (also used here!)</li><li>persisted on disk storage organisation/&rsquo;table b-trees&rsquo;. &lt;&ndash; we&rsquo;re here.</li></ol><p>Why is it called a B-Tree? According to one of the co-inventor&rsquo;s <a href=https://vimeo.com/73357851>Edward M. McCreight it&rsquo;s short for &ldquo;balance&rdquo;</a> &ndash; but could mean anything :)</p><h2 id=implementation-high-level-ideas>Implementation high level ideas</h2><p>Considerations:</p><ul><li>Performance (Access Patterns - everything is about access patterns)</li><li>Correctness & Testing</li><li>Durability (what&rsquo;s a block?, brief overview: buffered IO, mmap, directIO.)</li></ul><p>performance big ideas overview:</p><ul><li>why do we want search trees? balancing and order</li><li>going beyond Big-O - logarithmic acess.</li><li>mutability vs immutability</li><li>concurrency</li><li>locality of reference(time/space) (keep stuff close togther)</li></ul><h2 id=b-trees-in-memory>B Trees (In-Memory)</h2><p>A simple and useful way of thinking of access and logarithmic bisection is a Tree of a 2-D array:</p><p><code>[[1,2,3], [4,6], [9,11,12]]</code></p><p>visualisation:
<a href=https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html>https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p><p><img src=/btree.png alt="a simple btree example"></p><p>desired properties:</p><ul><li>high fanout (dense trees)</li><li>short height</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>Simple Persistent B Plus Tree.
</span></span></span><span class=line><span class=cl><span class=cm>Node keys are assumed to be signed integers and values also.
</span></span></span><span class=line><span class=cl><span class=cm>Persistence is achieved using a naive bufio.Writer + flush.
</span></span></span><span class=line><span class=cl><span class=cm>Concurrency control using a simple globally blocking RWMutex lock.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>B-Tree implementations have many implementation specific details 
</span></span></span><span class=line><span class=cl><span class=cm>and optimisations before they&#39;re &#39;production&#39; ready, notably they 
</span></span></span><span class=line><span class=cl><span class=cm>may use a free-list to hold &#39;free&#39; pages and employ 
</span></span></span><span class=line><span class=cl><span class=cm>sophisticated concurrency control. 
</span></span></span><span class=line><span class=cl><span class=cm>see also: CoW semantics, buffering, garbage collection etc
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>// learn more:
</span></span></span><span class=line><span class=cl><span class=cm>// etcd: https://pkg.go.dev/github.com/google/btree
</span></span></span><span class=line><span class=cl><span class=cm>// sqlite: https://sqlite.org/src/file/src/btree.c
</span></span></span><span class=line><span class=cl><span class=cm>// wiki: https://en.wikipedia.org/wiki/B%2B_tree
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>Definition:</p><p>A B plus tree with an arbitrary max degree 3, degree is the number of pointers/children each node can point to/hold:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>MAX_DEGREE</span> <span class=p>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>ROOT_NODE</span> <span class=nx>NodeType</span> <span class=p>=</span> <span class=kc>iota</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>INTERNAL_NODE</span>
</span></span><span class=line><span class=cl>	<span class=nx>LEAF_NODE</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>BTree</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>root</span> <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>A node:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Node</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>kind</span>     <span class=nx>NodeType</span>
</span></span><span class=line><span class=cl>	<span class=c1>// maintaining a parent pointer is expensive
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// in internal nodes especially
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>parent</span>   <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>keys</span>     <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>children</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>data</span>     <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// sibling pointers these help with deletions + range queries
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>next</span>     <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>previous</span> <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Operations Overview</strong>:</p><ul><li>access</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>Node</span><span class=p>)</span> <span class=nf>basicSearch</span><span class=p>(</span><span class=nx>key</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>children</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// you are at a leaf Node and can now access stuff
</span></span></span><span class=line><span class=cl><span class=c1>// or this is the leaf node that should contain stuff
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>low</span><span class=p>,</span> <span class=nx>high</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>keys</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>low</span> <span class=o>&lt;=</span> <span class=nx>high</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>mid</span> <span class=o>:=</span> <span class=nx>low</span> <span class=o>+</span> <span class=p>(</span><span class=nx>high</span><span class=o>-</span><span class=nx>low</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>n</span><span class=p>.</span><span class=nx>keys</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=o>==</span> <span class=nx>key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>n</span><span class=p>.</span><span class=nx>keys</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>low</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>high</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nx>children</span><span class=p>[</span><span class=nx>low</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>insertion/split algorithm</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>node</span><span class=p>)</span> <span class=nf>split</span><span class=p>(</span><span class=nx>midIdx</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// first find a leaf node.
</span></span></span><span class=line><span class=cl><span class=c1>// every node except the root node must respect the inquality:
</span></span></span><span class=line><span class=cl><span class=c1>// branching factor - 1 &lt;= num keys &lt; (2 * branching factor) - 1
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// if this doesn&#39;t make sense ignore it. The take away:
</span></span></span><span class=line><span class=cl><span class=c1>// every node except root has a min/max num keys or it&#39;s invalid.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// edge case, how to handle the root node?
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// node is full: promotion time, split keys into two halves
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>splitPoint</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>keys</span><span class=p>[</span><span class=nx>midIdx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=nx>leftKeys</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>keys</span><span class=p>[:</span><span class=nx>midIdx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=nx>rightKeys</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>keys</span><span class=p>[</span><span class=nx>midIdx</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>.</span><span class=nx>keys</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=nx>splitPoint</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>leftNode</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>node</span><span class=p>{</span><span class=nx>kind</span><span class=p>:</span> <span class=nx>LEAF_NODE</span><span class=p>,</span> <span class=nx>keys</span><span class=p>:</span> <span class=nx>leftKeys</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>rightNode</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>node</span><span class=p>{</span><span class=nx>kind</span><span class=p>:</span> <span class=nx>LEAF_NODE</span><span class=p>,</span> <span class=nx>keys</span><span class=p>:</span> <span class=nx>rightKeys</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>.</span><span class=nx>children</span> <span class=p>=</span> <span class=p>[]</span><span class=o>*</span><span class=nx>node</span><span class=p>{</span><span class=nx>leftNode</span><span class=p>,</span> <span class=nx>rightNode</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// -- LEAF
</span></span></span><span class=line><span class=cl><span class=c1>//  (internal node(left))  (internal node(right))
</span></span></span><span class=line><span class=cl><span class=c1>//   \               /
</span></span></span><span class=line><span class=cl><span class=c1>//   (current leaf node)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// recurse UP from curr to node which may overflow,
</span></span></span><span class=line><span class=cl><span class=c1>// check that we&#39;re not full if full, we split
</span></span></span><span class=line><span class=cl><span class=c1>// again allocate a new node(s)
</span></span></span><span class=line><span class=cl><span class=c1>// --snipped for clarity
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>deletion
Two operations, steal/redistribution/rebalancing and merging:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>Node</span><span class=p>)</span> <span class=nf>merge</span><span class=p>(</span><span class=nx>sibling</span> <span class=o>*</span><span class=nx>Node</span><span class=p>,</span> <span class=nx>key</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// delete data from leaf node
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// steal sibiling fist, if underfull --snipped
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// do stuff to prepare for merging, assume we _can_ merge
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// deallocate/collapse underflow node
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sibling</span><span class=p>.</span><span class=nx>data</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>sibling</span><span class=p>.</span><span class=nx>data</span><span class=p>,</span> <span class=nx>n</span><span class=p>.</span><span class=nx>data</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>node</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>sibling</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>children</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>node</span> <span class=o>==</span> <span class=nx>n</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>n</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>children</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>children</span><span class=p>[:</span><span class=nx>i</span><span class=p>],</span> <span class=nx>n</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>children</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// recurse UPWARD and check for underflow
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>k</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>sibling</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>keys</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>k</span> <span class=o>==</span> <span class=nx>key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>sibling</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>keys</span> <span class=p>=</span> <span class=nf>cut</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>sibling</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>keys</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>keys</span><span class=p>)</span> <span class=p>&lt;</span> <span class=nb>int</span><span class=p>(</span><span class=nx>math</span><span class=p>.</span><span class=nf>Ceil</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nx>MAX_DEGREE</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>f</span> <span class=nx>sibling</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>sibling</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>preMerge</span><span class=p>();</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>mergeSibling</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>sibling</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=b-trees-going-to-disk>B Trees (Going to Disk)</h2><p>Cannot reference memory using pointers. Can no longer allocate/deallallocate freely.
We <code>read/write/seek</code> to the operating system, in fixed size blocks, commonly 4KiB - 16KiB.</p><p>Classic B+Tree paper uses a triplet -<code>{pointer/offset to child, key, value}</code>, limited by fixed size storage (fragmentation is difficult).</p><p>the &ldquo;classic&rdquo; datafile layout:</p><pre tabindex=0><code>+++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ header | {p1, key1, value1}, {p2, key2, value3}  .. +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++
</code></pre><p>Slotted Pages are common in most database row/tuple oriented implementations such as SQLite and Postgres. Slotted pages are used to solve the problems space reclaimation and variable size data records. In columnar format encoding such as <a href=https://parquet.apache.org/docs/file-format/data-pages/encodings/>parquet</a> a <a href=https://en.wikipedia.org/wiki/LEB128>modern variable length encoding</a> is used and a <a href=https://en.wikipedia.org/wiki/Dictionary_coder>dictionary maintained</a> of data pages that is compressed and tightly packed.</p><p>For e.g <a href=https://www.postgresql.org/docs/current/storage-page-layout.html>the page layout in postgres</a>:
<img src=https://www.postgresql.org/docs/current/pagelayout.svg alt="postgres page layout"></p><p>The logical view of the datafile:</p><pre tabindex=0><code>[header (fixed size)] [page(s) 4KiB | ...] [trailer(fixed size)]
</code></pre><p>show me the code - the high level &ldquo;page&rdquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Page is (de)serialised disk block similar to: https://doxygen.postgresql.org/bufpage_8h_source.html
</span></span></span><span class=line><span class=cl><span class=c1>// It is a contigous 4kiB chunk of memory, both a logical and physical representation of data.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Page</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>header</span> <span class=nx>header</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>cellPointers</span> <span class=p>[]</span><span class=kt>int16</span>
</span></span><span class=line><span class=cl>	<span class=nx>cells</span>        <span class=p>[]</span><span class=nx>cell</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>its fixed size byte page header:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>pageHeader</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Represents a marker value to indicate that a file is a Bolt DB.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// copy/pasta as a magic number is &#39;magic&#39; and kind of madeup.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>magic</span>     <span class=kt>uint32</span> <span class=c1>// 4 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>PageID</span>    <span class=kt>uint32</span> <span class=c1>// 4 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Reserve</span>   <span class=kt>uint32</span> <span class=c1>// 4 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>FreeSlots</span> <span class=kt>uint16</span> <span class=c1>// 2 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// the physical offset mapping to the begining
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// and end of an allocated block on the datafile for this page
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>PLower</span>    <span class=kt>uint16</span> <span class=c1>// 2 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>PHigh</span>     <span class=kt>uint16</span> <span class=c1>// 2 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>NumSlots</span>  <span class=kt>byte</span>   <span class=c1>// 1 byte (uint8)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// all cells are of type CellLayout ie is key/pointer or key/value cell?
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>CellLayout</span> <span class=kt>byte</span> <span class=c1>// 1 byte (uint8)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>pageType</span>   <span class=kt>byte</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and finally the cell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>cell</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cellId</span>    <span class=kt>int16</span>
</span></span><span class=line><span class=cl>	<span class=nx>keySize</span>   <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>	<span class=nx>valueSize</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>	<span class=nx>keys</span>      <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=nx>data</span>      <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>naively flushing a page + <code>fsync</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Page</span><span class=p>)</span> <span class=nf>Flush</span><span class=p>(</span><span class=nx>datafile</span> <span class=o>*</span><span class=nx>os</span><span class=p>.</span><span class=nx>File</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>buf</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>datafile</span><span class=p>.</span><span class=nf>Seek</span><span class=p>(</span><span class=nb>int64</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>PLower</span><span class=p>),</span> <span class=nx>io</span><span class=p>.</span><span class=nx>SeekStart</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>binary</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>buf</span><span class=p>,</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>p</span><span class=p>.</span><span class=nx>pageHeader</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>binary</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>buf</span><span class=p>,</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>p</span><span class=p>.</span><span class=nx>cellPointers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>binary</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>buf</span><span class=p>,</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>p</span><span class=p>.</span><span class=nx>cells</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>buf</span><span class=p>.</span><span class=nf>WriteTo</span><span class=p>(</span><span class=nx>datafile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>datafile</span><span class=p>.</span><span class=nf>Sync</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;written %v bytes to disk at pageID %v&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>PageID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and fetching it back:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>pageDictionary</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span> 
</span></span><span class=line><span class=cl><span class=c1>// --snipped, tldr; hashmap conceptually
</span></span></span><span class=line><span class=cl><span class=c1>// maps the page ID to an actual offset
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Fetch</span><span class=p>(</span><span class=nx>pageId</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>datafile</span> <span class=o>*</span><span class=nx>os</span><span class=p>.</span><span class=nx>File</span><span class=p>)</span> <span class=p>(</span><span class=nx>Page</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>page</span> <span class=nx>Page</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>datafile</span><span class=p>.</span><span class=nf>Seek</span><span class=p>(</span><span class=nx>pageDictionary</span><span class=p>[</span><span class=nx>pageID</span><span class=p>],</span> <span class=nx>io</span><span class=p>.</span><span class=nx>SeekStart</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>binary</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>datafile</span><span class=p>,</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>page</span><span class=p>.</span><span class=nx>pageHeader</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>page</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>There&rsquo;s some cool optimisations we can do!</p><h2 id=miscellaneous>Miscellaneous</h2><ul><li>magic numbers: For e.g boltdb&rsquo;s magic number - tldr; random number to uniquely discern bin data reads.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>magic</span> <span class=kt>uint32</span> <span class=p>=</span> <span class=mh>0xED0CDAED</span>
</span></span></code></pre></div><ul><li><p><a href=https://github.com/oyekanmiayo/b-plus-tree/blob/main/v3/format/bin_search_indirect_pointers.go>binary search of cells</a></p></li><li><p><a href=https://www.sqlite.org/fileformat2.html#ovflpgs>overflow pages</a> + <a href=https://github.com/oyekanmiayo/b-plus-tree/blob/main/v3/vacuum.go>vaccum</a></p></li></ul><p>See the <a href=https://github.com/oyekanmiayo/b-plus-tree>demo repository for more examples!</a></p><h2 id=future-maybe-never->Future, Maybe Never :)</h2><pre tabindex=0><code>- The pitfalls of memory: allocation, fragmentation &amp; corruption
- concurrency mechanisms - snapshots, OCC/MVCC
- async split/merge/delete
- BTStack/Breadcrumbs
- lazy traversal: Cursor/Iter
- more optimisations/variants: B-link, CoW B-Trees, FD-Trees etc
- robust testing and correctness guarantees
- se(de)serialisation to network (replication)
- DIY a freelist!
- IO_URING/async direct/IO
- durability! DIY a WAL or smaller &#34;rollback journal&#34;
- good benchmarking &amp; profiling etc see tools of the trade
</code></pre><h2 id=tools-of-the-trade>Tools of the Trade</h2><p>Base your judgement on empirical fact:</p><ul><li>a good debugger or not (<a href=https://www.cs.cmu.edu/~gilpin/tutorial/>gdb</a> etc)</li><li><a href=https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html>flamegraphs</a></li><li>benchmarking</li><li>tests - unit, integration, fuzzing, proptests, simulations etc</li></ul><p>Performance comes from thinking wholistically about hardware and software together.
Optimizations bear the fruits of pretty benchmarks and complexity.
The first big piece is concurrency and parallelism.</p><p>tldr; the hard part about building storage engines is debugging and testing them, old databases are good because time spent in production uncovering (or not uncovering bugs).</p><p>In the real world stuff goes wrong(the operating system hides hardware and software faults, but you have to care), data loss is bad and is a big no-no.</p><h3 id=running-in-production-correctness-testing--safety>Running in production: Correctness, Testing & Safety</h3><p>Complexity is <strong>evil</strong> but unavoidable, non-determinism makes you helpless.</p><p>testing methodology, loom - concurrency is hard etc:</p><ul><li>How SQLlite is tested: <a href=https://www.sqlite.org/testing.html>https://www.sqlite.org/testing.html</a></li><li>Valgrind, Address and Memory Sanitizer</li><li><a href=https://www.cs.utexas.edu/~bornholt/papers/shardstore-sosp21.pdf>https://www.cs.utexas.edu/~bornholt/papers/shardstore-sosp21.pdf</a></li><li><a href=https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/DESIGN.md#safety>https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/DESIGN.md#safety</a></li><li><a href=https://apple.github.io/foundationdb/testing.html>https://apple.github.io/foundationdb/testing.html</a></li><li>many more&mldr;</li></ul><h2 id=further-reading-storage-engine-architecture>Further reading: storage engine architecture</h2><p>Move towards modularization of database components, decoupled query & execution engine(velox, datafusion etc), storage engine see: <a href=https://apple.github.io/foundationdb/layer-concept.html>foundationDB</a>.</p><p>What the heck is going on in your favorite database? <em>select/biased</em> popular deep dives into
popular storage engines for: postgres/postgres, kubernetes/etcd, mysql/InnoDB, mongodb(WiredTiger):</p><p>postgres:
<a href=https://postgrespro.com/blog/pgsql/4161516>https://postgrespro.com/blog/pgsql/4161516</a></p><p>etcd: <a href=https://etcd.io/docs/v3.5/learning/data_model/>https://etcd.io/docs/v3.5/learning/data_model/</a></p><p>innodb: <a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-physical-structure.html>https://dev.mysql.com/doc/refman/8.0/en/innodb-physical-structure.html</a></p><p>mongodb: <a href=https://source.wiredtiger.com/11.2.0/arch-btree.html>https://source.wiredtiger.com/11.2.0/arch-btree.html</a></p><p>Things we&rsquo;ve come to want/expect out of modern databases:</p><ul><li>Seperation of Storage and Compute: <a href=https://clickhouse.com/docs/en/guides/separation-storage-compute>https://clickhouse.com/docs/en/guides/separation-storage-compute</a></li><li>Multitenancy: <a href=https://github.com/neondatabase/neon/blob/main/docs/multitenancy.md>https://github.com/neondatabase/neon/blob/main/docs/multitenancy.md</a></li><li>Distribution/Replication: Availability, Redundancy & Serverless style scale</li><li>DBaaS/Cloud Native Stateful Backend services + Database engine, supabase etc</li></ul></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>Copyright ¬© 2024 Haile Lagi</a><div><span>private inquiries: hailelagi[at]gmail.com</span></div><div><span>or informally(twitter/x): https://x.com/haile_lagi</span></div></footer></body></html>