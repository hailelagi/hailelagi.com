<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=”og:title” content="How do databases count? | Haile (ሐይሌ)"><meta name=twitter:card content="summary"><meta name=twitter:title content="How do databases count? | Haile (ሐይሌ)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>How do databases count?</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=notes>notes</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>How do databases count?</h1><time>November 5, 2024</time><meta name=twitter:card content="summary">
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><p>Given the simple query below, how does a database count?</p><pre tabindex=0><code>psql -U postgres
select count(distinct col1) from table1;
</code></pre><p>Let&rsquo;s ask the database directly, <a href=https://www.postgresql.org/docs/current/using-explain.html>in this case, it&rsquo;s postgres</a>:</p><pre tabindex=0><code>explain analyze select count(distinct col1) from table1;
</code></pre><p>This produces a series of algorithmic steps and structures specific to a database, outputted as a <em>tree</em> of &ldquo;paths&rdquo;, which you can <em>read bottom-up</em>, a trivial example which is <a href=https://wiki.postgresql.org/wiki/Inlining_of_SQL_functions><em>inlined</em></a> and doesn&rsquo;t need a series of &lsquo;optimisation passes&rsquo;:</p><pre tabindex=0><code>postgres=# explain analyze select 1 + 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Result  (cost=0.00..0.01 rows=1 width=4) (actual time=0.001..0.012 rows=1 loops=1)
 Planning Time: 0.522 ms
 Execution Time: 0.128 ms
(3 rows)
</code></pre><p>This is not the only representation of a query plan, sqlite on the other hand does a curious thing, instead of holding a tree as an internal representation, it compiles <a href=https://www.sqlite.org/opcode.html>down to bytecode</a>, why it makes this decision is a plenty interesting design space<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>:</p><pre tabindex=0><code>sqlite&gt; explain select 1 + 1;
addr  opcode         p1    p2    p3    p4             p5  comment      
----  -------------  ----  ----  ----  -------------  --  -------------
0     Init           0     4     0                    0   Start at 4
1     Add            2     2     1                    0   r[1]=r[2]+r[2]
2     ResultRow      1     1     0                    0   output=r[1]
3     Halt           0     0     0                    0   
4     Integer        1     2     0                    0   r[2]=1
5     Goto           0     1     0                    0   
</code></pre><p>If you&rsquo;d rather see the plan, rather than reading opcodes:</p><pre tabindex=0><code>sqlite&gt; explain query plan select 1 + 1;
QUERY PLAN
`--SCAN CONSTANT ROW
</code></pre><p>A query plan is the <em>output</em> of a program, like all programs, it has a rich history, architectural decisions, algorithms, datastructures, trade-offs and constraints. It takes as input a <em>query</em> typically in a <em>query language</em> here it&rsquo;s SQL and lets you retrieve &lsquo;facts&rsquo; by isolating the how from the underlying storage, this <strong>decoupling</strong> gives many benefits and in <a href=https://en.wikipedia.org/wiki/Data_independence>hindsight is obvious</a>, but wasn&rsquo;t always so, until someone(s) figured it out<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><pre tabindex=0><code>postgres=# select 1 + 1;
 ?column? 
----------
        2
(1 row)
</code></pre><p>To answer our question, a tiny, not at all functional, but illustrative, query engine in <a href=https://github.com/hailelagi/peppermint>less than 500 lines</a> of rust:</p><pre tabindex=0><code>select count(distinct col) from table;
</code></pre><p>The goals of a query engine specify the <em>need</em> to be <strong><em>correct</em></strong> and <strong><em>fast</em></strong> as data grows. Correctness is an interesting word, and it has a context that&rsquo;s rooted in a two part formalism, called <a href=https://en.wikipedia.org/wiki/Relational_algebra><em>relational algebra</em></a> and <strong>relational calculus.</strong></p><p>Of interest is how the first formalism describes a number of operations on a <em>unordered collection</em> of sets:</p><ul><li>selection</li><li>projection</li><li>union</li><li>intersection</li><li>difference</li><li>product(cross product)</li><li>join</li><li>division(*)</li></ul><p>and a few useful modern extensions, like sorting, windows, aggregates etc.</p><p>To answer this query, it seems we need to <em>plan</em> several things, two <em>logical operators</em> or <em>logical nodes</em> which define this transformation:</p><ol><li>select - to specify what we want</li><li>projection - to specify a few details about what is of interest</li></ol><p>and a <a href=https://www.postgresql.org/docs/9.2/functions.html>function</a>, in this case an <strong>aggregate function</strong> called <code>COUNT(expr)</code>, and finally some
way to represent relations in this naive engine, we don&rsquo;t have a real &lsquo;schema&rsquo; quite yet or ever will, but you could imagine a relation as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>schema: relation + col -&gt; row mapping
</span></span></span><span class=line><span class=cl><span class=cm>storage(tuples): [{k,v}, {k,v}, {k,v}, {k,v}]
</span></span></span><span class=line><span class=cl><span class=cm>*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug, Clone)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Relation</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>col_names</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>rows</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>A selection here does a full scan and filters out based on the predicate:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// selection table/relation + predicate (expr = true | false | unknown)
</span></span></span><span class=line><span class=cl><span class=c1>// σ predicate(R). SQL: SELECT * FROM R WHERE a_id = &#39;a2&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>select</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>idx</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>expr</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Relation</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>rows</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>filter</span><span class=p>(</span><span class=o>|</span><span class=n>row</span><span class=o>|</span><span class=w> </span><span class=n>row</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>expr</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>cloned</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Relation</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>col_names</span>: <span class=nc>self</span><span class=p>.</span><span class=n>col_names</span><span class=p>.</span><span class=n>clone</span><span class=p>(),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>rows</span>: <span class=nc>result</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>A projection here is a <em>modifier</em> operation over the set:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Projection: modification(r/w/order) over cols, changes the shape of output/attributes
</span></span></span><span class=line><span class=cl><span class=c1>// π(a1,a2),. . . , (a)n(R).
</span></span></span><span class=line><span class=cl><span class=c1>// SQL: SELECT b_id-100, a_id FROM R WHERE a_id = &#39;a2&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>projection</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>columns</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>usize</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nc>Relation</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>rows</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>row</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>columns</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|&amp;</span><span class=n>col_idx</span><span class=o>|</span><span class=w> </span><span class=n>row</span><span class=p>[</span><span class=n>col_idx</span><span class=p>].</span><span class=n>clone</span><span class=p>()).</span><span class=n>collect</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}).</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>col_names</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>columns</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|&amp;</span><span class=n>col_idx</span><span class=o>|</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>col_names</span><span class=p>[</span><span class=n>col_idx</span><span class=p>].</span><span class=n>clone</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Relation</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>col_names</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>rows</span>: <span class=nc>result</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Now we have a <strong>logical plan</strong> of operations and transformations on this query, but it&rsquo;s defined in a <em>syntax</em> for these operations,
re-enter SQL, or was it SEQUEL? Of note is the observation, the <strong>logical operations are independent of the syntax</strong> used to describe them.
We need to first parse the sql, and build a simplified abstract syntax tree where the nodes are the logical operators: selection, projection
and preserving the semantics of applying the <code>count</code>, luckily this query engine doesn&rsquo;t need to support the SQL standard or dialects!
and we can cut corners :) , we can just parse out exactly what&rsquo;s needed, without <a href=https://docs.rs/sqlparser/latest/sqlparser/ast/trait.Visitor.html>walking the tree</a> or <a href=https://en.wikipedia.org/wiki/Recursive_descent_parser>using a pretty cool generalization over a grammar</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// parser.rs parse SELECT COUNT(DISTINCT col) FROM table; 
</span></span></span><span class=line><span class=cl><span class=c1>// and produces a data structure post logical we&#39;d now pass to the
</span></span></span><span class=line><span class=cl><span class=c1>// &#39;physical/execution&#39; planning stage, select indices etc
</span></span></span><span class=line><span class=cl><span class=c1>// in this example, there&#39;s only one possible strategy `SeqScan`
</span></span></span><span class=line><span class=cl><span class=c1>// in a strict sense is a combined logical + physical?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SelectStatement</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>projection</span>: <span class=nc>AggregateExpression</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>function</span>: <span class=nc>Aggregation</span>::<span class=n>Count</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>column</span>: <span class=nc>Column</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>name</span>: <span class=s>&#34;col&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>distinct</span>: <span class=nc>true</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>table</span>: <span class=s>&#34;table&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span></code></pre></div><h3 id=statistics--costs>Statistics & Costs</h3><p>Lastly, all that&rsquo;s left is to <code>count</code>. Which brings us to feature two &ndash; <strong>performance</strong>. A historical glance reveals some influential architectural decisions, we&rsquo;ve established the need to seperate the <em>logical</em> what of a query from the <em>physical/execution</em> how the query finds,
in this simplified all-in-one planner, we gloss over that very important detail and further yet, realised sql (and dialects) are really syntactic abstractions.</p><p>Why is the performance of counting interesting?</p><blockquote><p>The situation gets much more complex when operations like projections, selections, multiple joins
in combination with various boolean operations appear in queries. As an example, the relational system system R has a sophisticated query optimiser. In order to perform its task, that programme keeps <strong>several statistics</strong> on
relations of the database. The most important ones are the <strong>sizes of relations</strong> as well
as <strong>the number of different elements of some key fields</strong> [8]. This information is used
to determine the selectivity of attributes at any given time in order to decide the
choice of keys and the choice of the appropriate algorithms to be employed when
computing relational operators. The choices are made in order <strong>to minimise a certain cost function</strong> that depends on specific CPU and disk access costs as well as <strong>sizes and cardinalities</strong> of relations or fields. In system R, this information is
periodically recomputed and kept in catalogues that are companions to the database records and indexes<sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote><p>In postgres this subsystem is called the <a href=https://www.postgresql.org/docs/current/monitoring-stats.html>Cumulative Statistics System</a>, hopefully this contextualizes <em>why</em> keeping track of counts and making them fast is important. It&rsquo;s not just to serve the sql query aggregate function <code>COUNT</code>, it&rsquo;s also quite useful internally for the planner as well.</p><h3 id=naive-counting>Naive Counting</h3><p>There are two flavors of counting, we&rsquo;re interested in:</p><ol><li>size (counting all elements)</li><li>cardinality (roughly, counting unique elements)</li></ol><p>Counting elements for an exact size, could be as simple as a counter, an <a href=https://c9x.me/x86/html/file_module_x86_id_5.html><code>ADD</code> instruction is very fast</a>, but if we&rsquo;re storing <em>alot of different counts</em>, wouldn&rsquo;t it be nice if we could save on memory too? what if you don&rsquo;t care about an <em>exact</em> count? say we only desire a <em>rough count</em> over some interval to make some informed decisions?</p><p>On the other side of the coin, how do we count <em>unique elements</em>?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// This is computationally inefficient in time</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>countUniqStack</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mystack</span> <span class=o>:=</span> <span class=nx>MyStack</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>element</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>arr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// expensive check</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>mystack</span><span class=p>.</span><span class=nf>contains</span><span class=p>(</span><span class=nx>element</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>mystack</span><span class=p>.</span><span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>mystack</span><span class=p>.</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>element</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>mystack</span><span class=p>.</span><span class=nx>stack</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Perhaps a hashmap which is <code>O(1)</code>?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// This is computationally inefficient in space</span>
</span></span><span class=line><span class=cl><span class=c1>// For a large set s, we must `make` unused space &#39;incase&#39;</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>countUniqMap</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>seen</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>uniqs</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>element</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>arr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>seen</span><span class=p>[</span><span class=nx>element</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>uniqs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>uniqs</span><span class=p>,</span> <span class=nx>element</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>			<span class=nx>seen</span><span class=p>[</span><span class=nx>element</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It seems like a stack and hashmap won&rsquo;t work, how does one store less and compute only what&rsquo;s necessary?</p><h3 id=probabilistic-counting>Probabilistic counting</h3><p>Two interesting and clever data structures, relax the requirement of counting <em>exact</em> elements in a stream by using probabilistic schemes that offer a <em>sketch</em>, the Morris Counter<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> and the HyperLogLog. The morris counter saves on the <em>space</em> that&rsquo;s required to represent or hold the reprentation of a <em>stream</em>, it gets a little &ldquo;mathy&rdquo; <a href=https://gregorygundersen.com/blog/2019/11/11/morris-algorithm/>if you&rsquo;re interested this excellent blog post has a great explaination to intuit the math</a>.</p><p>The hyperloglog on the other hand allows for the estimation of cardinality of datasets to the tune of over a billion! using only ~1.5kilobytes, and a margin of error of roughly 98% accuracy, those are incredible numbers, <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> how does it work?</p><p>The input to this algorithm is a <em>continuous stream</em> (elements are read sequentially) say:</p><p><code>["hello", "bye, "hello", "world", "universe", "foo"]</code></p><p>We want to perform a <em>single pass</em> over these elements(<em>multiset</em> in the paper) and the output an <em>estimate of the cardinality</em>
of unique items when we&rsquo;re done by utilising a hash function to produce a uniformly random binary over each element:</p><p><code>hash_fn : Domain → {0, 1}∞</code></p><p>Which might produces a binary stream(S) like:</p><pre tabindex=0><code>[101010, 100000, 00100, 0000101, 0100101]
</code></pre><p>The paper draws attention on making some observations about <em>patterns</em> in the bits produce which allow us to infer a plausible estimate of the unknown cardinality n. These observations are:</p><ul><li>Bit-pattern observables</li><li>Order statistics observables</li></ul><p>In particular we&rsquo;re focused on the first <em>bit-pattern</em> observables:</p><div class=callout-warning>💡
in the stream S at the beginning of a string a bit-pattern 0^(ρ−1) . 1 is more or less a likely indication that the cardinality n of S is at least 2ρ</div><p>Once we&rsquo;ve identified this pattern in the hashed bit, we can then <em>combine</em>, several &ldquo;estimation passess&rdquo; by making each &ldquo;guess&rdquo; in parallel and later combining them using a pretty neat formula, it&rsquo;s a short algorithm but requires some clever bit shifting and finding a uniform hash that behaves properly.</p><p>HyperLogLog is now a fairly standard data structure in analytics databases and realtime/main memory databases, a few examples of adoption in the postgres ecosystem are: <a href=https://docs.citusdata.com/en/stable/articles/hll_count_distinct.html>citus</a>, <a href=https://www.crunchydata.com/blog/high-compression-metrics-storage-with-postgres-hyperloglog>crunchydata</a> and <a href=https://docs.timescale.com/use-timescale/latest/hyperfunctions/approx-count-distincts/hyperloglog/>timescaleDB</a>, broadly at <a href=https://engineering.fb.com/2018/12/13/data-infrastructure/hyperloglog/>meta(presto)</a>, in <a href=http://research.google/pubs/hyperloglog-in-practice-algorithmic-engineering-of-a-state-of-the-art-cardinality-estimation-algorithm/>google</a> at <a href=https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions>Big Query</a>, <a href=https://antirez.com/news/75>Redis</a> and much more.</p><div class=callout-warning>💡
If you enjoyed reading this please consider thoughtfully sharing it with someone who might find it interesting!</div><h4 id=notes--references>Notes & References</h4><ul><li><a href=https://15445.courses.cs.cmu.edu/spring2023/notes/01-introduction.pdf>https://15445.courses.cs.cmu.edu/spring2023/notes/01-introduction.pdf</a></li><li><a href=https://15445.courses.cs.cmu.edu/fall2024/notes/02-modernsql.pdf>https://15445.courses.cs.cmu.edu/fall2024/notes/02-modernsql.pdf</a></li><li><a href=https://www.algorithm-archive.org/contents/approximate_counting/approximate_counting.html>https://www.algorithm-archive.org/contents/approximate_counting/approximate_counting.html</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://www.vldb.org/pvldb/vol11/p2209-kersten.pdf>Everything You Always Wanted to Know About Compiled and Vectorized Queries But Were Afraid to Ask</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://courses.cs.duke.edu/compsci516/cps216/spring03/papers/selinger-etal-1979.pdf>Access Path Selection in a Relational Database Management System</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://www.seas.upenn.edu/~zives/cis650/papers/System-R.PDF>System R</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://algo.inria.fr/flajolet/Publications/src/FlMa85.pdf>Probabilistic Counting Algorithms for Database Applications</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://www.inf.ed.ac.uk/teaching/courses/exc/reading/morris.pdf>Counting Large Numbers of Events in Small Registers </a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>Copyright © 2025 Haile Lagi</a><div><span>feel free to reach out: hailelagi[at]gmail.com</span></span></div></footer></body></html>