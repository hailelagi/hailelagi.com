<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=”og:title” content="B Tree Basics - Meta | Haile (ሐይሌ)"><meta name=twitter:card content="summary"><meta name=twitter:title content="B Tree Basics - Meta | Haile (ሐይሌ)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>B Tree Basics - Meta</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href=/bookshelf title=bookshelf>bookshelf</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=notes>notes</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>B Tree Basics - Meta</h1><time>February 27, 2024</time>
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><p>What is a Datastructure&rsquo;s memory representation? Everything is either a contigous block or pointer based.
Relevant search techniques: recursion, binary search - Olog(N) is powerful.</p><p>Why is it called a B-Tree? According to one of the co-inventor&rsquo;s <a href=https://vimeo.com/73357851>Edward M. McCreight it&rsquo;s short for &ldquo;balance&rdquo;</a> &ndash; but could mean anything :)</p><p>B Tree vs B+ Tree.</p><h2 id=things-to-not-think-about---yet>Things to NOT think about - (yet)</h2><pre tabindex=0><code>- Memory allocation: garbage collection and language choice
- The pitfalls of memory: fragmentation &amp; corruption
- pre-mature optimisation (serialisation, network calls etc)
- scope creep (adding fancy concurrency mechanisms - MVCC)
- pre-mature horizontal distribution (sharding, replication, unreliable network and the headaches of distributed systems etc)
- 2-3-Tree, Red black trees, LSM Trees, variants etc.
</code></pre><h2 id=implementation-high-level-ideas>Implementation high level ideas</h2><p>B-Trees are useful for:</p><ol><li>In-memory indexes (also used here!)</li><li>persisted on disk storage organisation. &lt;&ndash; we&rsquo;re here.</li></ol><p>Considerations:</p><ul><li>Performance (Access Patterns - everything is about access patterns)</li><li>Correctness & Testing</li><li>Durability (what&rsquo;s a block?, brief overview: buffered IO, mmap, directIO.)</li></ul><p>performance big ideas overview:</p><ul><li>why do we want search trees? balancing and order</li><li>going beyond Big-O</li><li>mutability vs immutability</li><li>concurrency</li><li>locality of reference (keep stuff close togther)</li></ul><h2 id=b-trees>B Trees</h2><p>visualisation:
<a href=https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html>https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p><p>desired properties:</p><ul><li>high fanout (dense trees)</li><li>short height</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>Simple Persistent B Plus Tree.
</span></span></span><span class=line><span class=cl><span class=cm>Node keys are assumed to be signed integers and values in a
</span></span></span><span class=line><span class=cl><span class=cm>slice of bytes. Persistence is achieved using a naive bufio.Writer 
</span></span></span><span class=line><span class=cl><span class=cm>interface pointer for simplicity.Concurrency control is achieved 
</span></span></span><span class=line><span class=cl><span class=cm>using a simple globally blocking RWMutex lock.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>B-Tree implementations have many implementation specific details 
</span></span></span><span class=line><span class=cl><span class=cm>and optimisations before they&#39;re &#39;production&#39; ready, notably they 
</span></span></span><span class=line><span class=cl><span class=cm>may use a free-list to hold cells in the node and employ 
</span></span></span><span class=line><span class=cl><span class=cm>sophisticated concurrency control.
</span></span></span><span class=line><span class=cl><span class=cm>// see also: CoW semantics
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>// learn more:
</span></span></span><span class=line><span class=cl><span class=cm>// etcd: https://pkg.go.dev/github.com/google/btree
</span></span></span><span class=line><span class=cl><span class=cm>// sqlite: https://sqlite.org/src/file/src/btree.c
</span></span></span><span class=line><span class=cl><span class=cm>// wiki: https://en.wikipedia.org/wiki/B%2B_tree
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>Definition:</p><p>A B plus tree with an arbitrary degree, degree is the number of pointers/children each node can point to/hold</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>BPlusTree</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>root</span>   <span class=o>*</span><span class=nx>node</span>
</span></span><span class=line><span class=cl>	<span class=nx>degree</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The internal node:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>node</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>keys</span>     <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>data</span>     <span class=o>*</span><span class=nx>bufio</span><span class=p>.</span><span class=nx>ReadWriter</span>
</span></span><span class=line><span class=cl>	<span class=nx>children</span> <span class=p>[]</span><span class=o>*</span><span class=nx>node</span>
</span></span><span class=line><span class=cl>	<span class=nx>isLeaf</span>   <span class=kt>bool</span>
</span></span><span class=line><span class=cl>	<span class=nx>next</span>     <span class=o>*</span><span class=nx>node</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Operations Overview</strong>:</p><ul><li>insertion</li><li>access</li><li>deletions</li></ul><p><strong>Insertion</strong></p><p><strong>Split/Merge/Rebalancing</strong></p><h2 id=tools-of-the-trade>Tools of the Trade</h2><p>Base your judgement on empirical fact:</p><ul><li>a good debugger or not (dbg etc)</li><li><a href=https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html>flamegraphs</a></li><li>benchmarking</li><li>tests - unit, integration, fuzzing, proptests, simulations etc</li></ul><p>Performance comes from thinking wholistically about hardware and software together.
Optimizations bear the fruits of pretty benchmarks and complexity.
The first big piece is concurrency and parallelism.</p><p>tldr; the hard part about building storage engines is debugging and testing them, old databases are good because time spent in production uncovering (or not uncovering bugs).</p><p>In the real world stuff goes wrong(the operating system hides hardware and software faults, but you have to care), data loss is bad and is a big no-no.</p><h3 id=running-in-production-correctness-testing--safety>Running in production: Correctness, Testing & Safety</h3><p>Complexity is <strong>evil</strong> but unavoidable, non-determinism makes you helpless.</p><p>testing methodology, loom - concurrency is hard etc:</p><ul><li>How SQLlite is tested: <a href=https://www.sqlite.org/testing.html>https://www.sqlite.org/testing.html</a></li><li>Valgrind, Address and Memory Sanitizer</li><li><a href=https://www.cs.utexas.edu/~bornholt/papers/shardstore-sosp21.pdf>https://www.cs.utexas.edu/~bornholt/papers/shardstore-sosp21.pdf</a></li><li><a href=https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/DESIGN.md#safety>https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/DESIGN.md#safety</a></li><li><a href=https://apple.github.io/foundationdb/testing.html>https://apple.github.io/foundationdb/testing.html</a></li><li>many more&mldr;</li></ul><h2 id=further-reading-storage-engine-architecture>Further reading: storage engine architecture</h2><p>Move towards modularization of database components, decoupled query & execution engine(velox, datafusion etc), storage engine see: <a href=https://apple.github.io/foundationdb/layer-concept.html>foundationDB</a>.</p><p>What the heck is going on in your favorite database? <em>select/biased</em> popular deep dives into
popular storage engines for: postgres/postgres, kubernetes/etcd, mysql/InnoDB, mongodb(WiredTiger):</p><p>postgres:
<a href=https://postgrespro.com/blog/pgsql/4161516>https://postgrespro.com/blog/pgsql/4161516</a></p><p>etcd: <a href=https://etcd.io/docs/v3.5/learning/data_model/>https://etcd.io/docs/v3.5/learning/data_model/</a></p><p>innodb: <a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-physical-structure.html>https://dev.mysql.com/doc/refman/8.0/en/innodb-physical-structure.html</a></p><p>mongodb: <a href=https://source.wiredtiger.com/11.2.0/arch-btree.html>https://source.wiredtiger.com/11.2.0/arch-btree.html</a></p><p>Things we&rsquo;ve come to want/expect out of modern databases:</p><ul><li>Seperation of Storage and Compute: <a href=https://clickhouse.com/docs/en/guides/separation-storage-compute>https://clickhouse.com/docs/en/guides/separation-storage-compute</a></li><li>Multitenancy: <a href=https://github.com/neondatabase/neon/blob/main/docs/multitenancy.md>https://github.com/neondatabase/neon/blob/main/docs/multitenancy.md</a></li><li>Distribution/Replication: Availability, Redundancy & Serverless style scale</li><li>DBaaS/Cloud Native Stateful Backend services + Database engine, supabase etc</li></ul></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>source</a>
Copyright © 2024 Haile Lagi<div id=sign-key><span>GPG key ID: 0298F4203ADC85E8</span></div></footer></body></html>