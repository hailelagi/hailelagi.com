<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=”og:title” content="Oops - Call Me Maybe? | Haile (ሐይሌ)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Oops - Call Me Maybe? | Haile (ሐይሌ)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>Oops - Call Me Maybe?</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href=/bookshelf title=bookshelf>bookshelf</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=writing>writing</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Oops - Call Me Maybe?</h1><time>May 19, 2024</time><meta name=twitter:card content="summary">
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><p>I&rsquo;m solving the fly.io distributed systems challenges for practice while reading part II of database internals with the <a href=https://x.com/sysdsgn>sysdsgn bookclub</a>.</p><p>The title of this post is inspired by <a href=https://aphyr.com/posts/316-call-me-maybe-etcd-and-consul>kyle kingsbury&rsquo; series of articles like this one</a> and <a href=https://aphyr.com/posts/315-call-me-maybe-rabbitmq>this one</a>. I thought it&rsquo;d also be funny to play it on repeat while solving/writing some of this :)</p><iframe src=https://open.spotify.com/embed/track/20I6sIOMTCkB6w7ryavxtO width=100% height=380 frameborder=0 allowtransparency=true allow=encrypted-media></iframe><h2 id=1-echo>1. echo</h2><p>saying hello world! but distributed systems style, it&rsquo;s mostly boilerplate setup,
reading the maelstrom docs and the go client docs, we instantiate a maelstrom node/binary, define an RPC style handler and return messages:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=o>:=</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nf>NewNode</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Register a handler for the &#34;echo&#34; message that responds with an &#34;echo_ok&#34;.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>n</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=s>&#34;echo&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>msg</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Unmarshal the message body as an loosely-typed map.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kd>var</span> <span class=nx>body</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Update the message type.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>body</span><span class=p>[</span><span class=s>&#34;type&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;echo_ok&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Echo the original message back with the updated message type.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Execute the node&#39;s message loop. This will run until STDIN is closed.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nf>Run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;ERROR: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=2-unique-id-generation-what-time-is-it>2. Unique ID Generation (What time is it?)</h2><p>In a single node/computer, generation of unique ids is typically achieved using a growing monontonic sequence such as a counter or the system clock.</p><p>In the view of a distributed system where each node could increment this counter simultaneously and the <a href=https://tigerbeetle.com/blog/three-clocks-are-better-than-one>the system clock is unreliable</a> there needs to be some way of solving this <a href="https://www.youtube.com/watch?v=mAyW-4LeXZo">global clock synchronisation problem</a> of not only skewing different &ldquo;times&rdquo; but logical ordering of events. What to do? We also want to prevent the need to exchange messages or co-ordination so lamport clocks are out!</p><ol><li>A pseudo logical event clock where we can represent causal dependencies as combinations of properties of our system for e.g the system clock + orignating node id + a random request id(tie breaker). Luckily for this challenge there aren&rsquo;t requirements for <strong>space</strong> or <strong>ordering</strong> or <strong>causality</strong>, only <strong>global uniqueness</strong>, which is naive but isn&rsquo;t too far off more sophisticated schemes <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>genNaive</span><span class=p>(</span><span class=nx>nodeID</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>requestID</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>FormatInt</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Int63n</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>sequenceId</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>FormatInt</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixMicro</span><span class=p>(),</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>originId</span> <span class=o>:=</span> <span class=nx>nodeID</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>identity</span> <span class=o>:=</span> <span class=nx>originId</span> <span class=o>+</span> <span class=nx>requestID</span> <span class=o>+</span> <span class=nx>sequenceId</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>ParseInt</span><span class=p>(</span><span class=nx>identity</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>64</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>id</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li><p>hash a seed over a really large key space (2**128 - 1) - a uuid.</p></li><li><p>The use of a central authority, such as an atomic clock + GPS and/or other clever distributed algorithms<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> provided by a <a href=https://cloud.google.com/spanner/docs/true-time-external-consistency>time server(s)</a>.</p></li></ol><h2 id=3-broadcast>3. Broadcast</h2><p>Our first &ldquo;official&rdquo; distributed algorithm! a way to gossip information to nodes. Incrementally we scaffold basic messaging,
sending data efficiently, simulating network partitions, variable latencies and interesting node topologies!</p><p>We keep all data we&rsquo;ve seen in-memory in a simple &ldquo;store&rdquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>store</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>index</span> <span class=kd>map</span><span class=p>[</span><span class=kt>float64</span><span class=p>]</span><span class=kt>bool</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span>   <span class=p>[]</span><span class=kt>float64</span>
</span></span><span class=line><span class=cl>	<span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a session is a wrapper instance of a maelstrom node
</span></span></span><span class=line><span class=cl><span class=c1>// that can read/write from a single store and `handle` messages
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>session</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>node</span>    <span class=o>*</span><span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>store</span>   <span class=o>*</span><span class=nx>store</span>
</span></span><span class=line><span class=cl>	<span class=nx>retries</span> <span class=kd>chan</span> <span class=nx>retry</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>reading, we simply take a <code>read</code> lock, respond with what&rsquo;s in our <code>log</code> so far.</p><p>If we get a <code>broadcast</code> message we concurrently attempt to send it to all our neighbours, excluding ourself, store it in <code>log</code> and <code>index</code> so we can test if we&rsquo;ve seen this message before and short circuit duplicate broadcast replies:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// spam everyone in this network we know of, and so on...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>dest</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>n</span><span class=p>.</span><span class=nf>NodeIDs</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>dest</span> <span class=o>==</span> <span class=nx>n</span><span class=p>.</span><span class=nf>ID</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>continue</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>dest</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>400</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>bgd</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>bgd</span><span class=p>,</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nf>SyncRPC</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>dest</span><span class=p>,</span> <span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// failure detection up next!
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}(</span><span class=nx>dest</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span></code></pre></div><p>Our failure detection algorithm is a simple FIFO queue using go&rsquo;s channels, for the un-initiated in go-ism, it&rsquo;s conceputally an <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.22.3:src/runtime/chan.go;l=33">&ldquo;atomic circular buffer&rdquo;</a>, if that doesn&rsquo;t mean much &ndash; it&rsquo;s a &lsquo;concurrent safe queue&rsquo;, so we can handle network partitions and variable latency async!
We send messages into a buffered channel, in our else block and read it (if/when) we have to retry in a seperate goroutine(s):</p><pre tabindex=0><code>s.retries &lt;- Retry{body: body, dest: dest, attempt: 20, err: err}
</code></pre><p>we guess-timate a queue size (I&rsquo;m not 100% about this bit lmk if I&rsquo;m wrong!):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> little&#39;s law: L (num units) = arrival rate * wait time
</span></span></span><span class=line><span class=cl><span class=cm> rate == 100 msgs/sec assuming efficient workload,
</span></span></span><span class=line><span class=cl><span class=cm> latency/wait mininum = 100ms, 400ms average
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> 100 * 0.4 = 40 msgs per request * 25 - 1(self) nodes 
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> = 960 queue size, will use ~1000
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>retries</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>retry</span><span class=p>,</span> <span class=mi>1000</span><span class=p>)</span>
</span></span></code></pre></div><p>The spurious errors and on/off successes and failures making this were&mldr; interesting to debug! non-deterministic systems are&mldr; something.
Anyway, a few <code>failureDetector</code> go routines are spawned and sleep until messages are in the queue.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>runtime</span><span class=p>.</span><span class=nf>NumCPU</span><span class=p>();</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=nf>failureDetector</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>What suprised me was the tweaking of the <code>deadline</code>
a longer deadline would lead to consistently more reliable delivery vs retrying in smaller intervals &ndash; not sure why, a lot of numbers here
are arbitrary and stuff I figured out empirically of what worked consistently via experimentation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// a naive failure detector :)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>failureDetector</span><span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>session</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>atttempts</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>r</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span><span class=p>.</span><span class=nx>retries</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=nx>r</span> <span class=o>:=</span> <span class=nx>r</span>
</span></span><span class=line><span class=cl>	  <span class=nx>atttempts</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	  <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>retry</span> <span class=nx>retry</span><span class=p>,</span> <span class=nx>attempts</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		  <span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>800</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		  <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		  <span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		  <span class=k>defer</span> <span class=nx>attempts</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		  <span class=nx>retry</span><span class=p>.</span><span class=nx>attempt</span><span class=o>--</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		  <span class=k>if</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>attempt</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			  <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>SyncRPC</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>dest</span><span class=p>,</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			  <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				  <span class=k>return</span>
</span></span><span class=line><span class=cl>			  <span class=p>}</span>
</span></span><span class=line><span class=cl>			  <span class=nx>s</span><span class=p>.</span><span class=nx>retries</span> <span class=o>&lt;-</span> <span class=nx>retry</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			  <span class=nx>log</span><span class=p>.</span><span class=nf>SetOutput</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			  <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;dead letter message slip loss beyond tolerance %v&#34;</span><span class=p>,</span> <span class=nx>retry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>r</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>atttempts</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=nx>atttempts</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>A perfect timeout-based failure detector exists only in a synchronous crash-stop system with reliable
links; in a partially synchronous system, a perfect failure detector does not exist</p><p>&ndash; <a href=https://www.cl.cam.ac.uk/teaching/2122/ConcDisSys/dist-sys-notes.pdf>https://www.cl.cam.ac.uk/teaching/2122/ConcDisSys/dist-sys-notes.pdf</a></p></blockquote><p>and finally we optimise! we&rsquo;re sending far too many messages and flooding the entire network! even if it&rsquo;s impossible to be both accurate and fast,
we try anyway &ndash; gotta get those p99s up, so far these are rookie numbers! there&rsquo;s a hint about network topology so let&rsquo;s re-examine that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>neighbors</span> <span class=p>[]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>session</span><span class=p>)</span> <span class=nf>topologyHandler</span><span class=p>(</span><span class=nx>msg</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>body</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>self</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>ID</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>topology</span> <span class=o>:=</span> <span class=nx>body</span><span class=p>[</span><span class=s>&#34;topology&#34;</span><span class=p>].(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>neighbors</span> <span class=p>=</span> <span class=nx>topology</span><span class=p>[</span><span class=nx>self</span><span class=p>].([]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>{</span><span class=s>&#34;type&#34;</span><span class=p>:</span> <span class=s>&#34;topology_ok&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>For this bit, I had to draw up the messsaging flow of the network topology on pen and paper. First I tried to send only to immediately connected neighbours. For example in a 5 node cluster of <code>a, b, c, d, e</code> a would neighbour <code>b, c</code> and so on forming a grid:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gd>-- // spam everyone in this network we know of, and so on...
</span></span></span><span class=line><span class=cl><span class=gd>-- for _, dest := range n.NodeIDs()
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>++ // send to our grid neighbors only
</span></span></span><span class=line><span class=cl><span class=gi>++ for _, dest := range neighbors
</span></span></span></code></pre></div><p><a href=https://learning.oreilly.com/library/view/database-internals/9781492040330/ch12.html>Database Internals chapter 12</a> and the <a href=https://github.com/jepsen-io/maelstrom/blob/main/doc/03-broadcast/02-performance.md>maelstrom docs</a> were also super helpful on where to go about exploring options, network topologies for broadcast are a deep topic, so we&rsquo;ll only review a very tiny subset we&rsquo;re interested in:</p><ol><li>a fully connected grid mesh (what we had before) <a href=https://en.wikipedia.org/wiki/Network_topology>to quote wikipedia</a>:</li></ol><blockquote><p>Networks designed with this topology are usually very expensive to set up, but provide a high degree of reliability due to the multiple paths for data that are provided by the large number of redundant links between nodes</p></blockquote><p>(side note: I&rsquo;ve worked on a system which delivered rpc messages as a <a href=https://www.erlang.org/doc/system/distributed.html#node-connections>full loosely connected network</a> using a <a href=https://www.erlang.org/doc/apps/kernel/global.html>global process registry</a> this heavily depends on cluster size and messaging patterns, if you can get away with being fully connected - you probably should.)</p><ol start=2><li>a tree topology - let&rsquo;s revisit <a href=https://en.wikipedia.org/wiki/Minimum_spanning_tree>spanning trees</a>. We&rsquo;re presented with seemingly contradictory goals - fast low-latency and reliable accurate broadcast, in a 25-node cluster with partitioned networks. What to do?</li></ol><p>I briefly discovered but did not implement other interesting algorithms/protocols <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> <sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> such as PlumTrees(the search term is &ldquo;epidemic Broadcast Trees&rdquo;), <a href=https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf>SWIM</a> used by <a href=https://www.serf.io/docs/internals/gossip.html>Consul&rsquo;s serf</a>, HyParView & HashGraph, and of course <a href=https://github.com/superfly/corrosion>fly.io&rsquo;s corrosion</a> (built specifically for service discovery) and more!</p><h2 id=4-grow-only-counter>4. Grow-Only Counter</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go></code></pre></div><h2 id=5-kafka-style-log>5. Kafka-Style Log</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go></code></pre></div><h2 id=6-totally-available-transactions>6. Totally-Available Transactions</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go></code></pre></div><div class=callout-warning>💡
If you enjoyed reading this please consider thoughtfully sharing it with someone who might find it interesting! I'm currently looking for work :)
You can reach me via my email or on x/twitter, details in the footer.</div><h3 id=references>References</h3><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://datatracker.ietf.org/doc/html/rfc4122#section-4.2.1>https://datatracker.ietf.org/doc/html/rfc4122#section-4.2.1</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://en.wikipedia.org/wiki/Snowflake_ID>https://en.wikipedia.org/wiki/Snowflake_ID</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=http://yellerapp.com/posts/2015-02-09-flake-ids.html>http://yellerapp.com/posts/2015-02-09-flake-ids.html</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://www.cockroachlabs.com/blog/living-without-atomic-clocks/>https://www.cockroachlabs.com/blog/living-without-atomic-clocks/</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://docs.riak.com/riak/kv/2.2.3/learn/concepts/clusters.1.html>https://docs.riak.com/riak/kv/2.2.3/learn/concepts/clusters.1.html</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf>https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://highscalability.com/gossip-protocol-explained/>https://highscalability.com/gossip-protocol-explained/</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>Copyright © 2024 Haile Lagi</a><div><span>private inquiries: hailelagi[at]gmail.com</span></div><div><span>or informally(twitter/x): https://x.com/haile_lagi</span></div></footer></body></html>