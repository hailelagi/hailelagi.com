<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=”og:title” content="Oops - Call Me Maybe? | Haile (ሐይሌ)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Oops - Call Me Maybe? | Haile (ሐይሌ)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>Oops - Call Me Maybe?</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href=/bookshelf title=bookshelf>bookshelf</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=writing>writing</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Oops - Call Me Maybe?</h1><time>April 20, 2024</time><meta name=twitter:card content="summary">
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><p>Documenting solving the fly.io distributed systems challenges. The title of this post is inspired by <a href=https://aphyr.com/posts/316-call-me-maybe-etcd-and-consul>kyle kingsbury&rsquo; series of articles like this one</a> and <a href=https://aphyr.com/posts/315-call-me-maybe-rabbitmq>this one</a>. I thought it&rsquo;d also be funny to play it on repeat while solving/writing this :)</p><iframe src=https://open.spotify.com/embed/track/20I6sIOMTCkB6w7ryavxtO width=100% height=380 frameborder=0 allowtransparency=true allow=encrypted-media></iframe><h2 id=1-echo>1. echo</h2><p>saying hello world! but distributed systems style, it&rsquo;s mostly boilerplate setup,
reading the maelstrom docs and the go client docs, we instantiate a maelstrom node/binary, define an RPC style handler and return messages:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=o>:=</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nf>NewNode</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Register a handler for the &#34;echo&#34; message that responds with an &#34;echo_ok&#34;.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>n</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=s>&#34;echo&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>msg</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Unmarshal the message body as an loosely-typed map.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kd>var</span> <span class=nx>body</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Update the message type.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>body</span><span class=p>[</span><span class=s>&#34;type&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;echo_ok&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Echo the original message back with the updated message type.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Execute the node&#39;s message loop. This will run until STDIN is closed.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nf>Run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;ERROR: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=2-unique-id-generation-what-time-is-it>2. Unique ID Generation (What time is it?)</h2><p>In a single node/computer, generation of unique ids is typically achieved using a growing monontonic sequence such as a counter or the system clock.</p><p>In the view of a distributed system where each node could increment this counter simultaneously and the <a href=https://tigerbeetle.com/blog/three-clocks-are-better-than-one>the system clock is unreliable</a> there needs to be some way of solving this <a href="https://www.youtube.com/watch?v=mAyW-4LeXZo">global clock synchronisation problem</a> of not only skewing different &ldquo;times&rdquo; but logical ordering of events. What to do?</p><ol><li>A pseudo logical event clock where we can represent casual dependencies as combinations of properties of our system for e.g the system clock + orignating node id + a random request id(tie breaker). Luckily for this challenge there aren&rsquo;t requirements for <strong>space</strong> or <strong>ordering</strong> or <strong>causality</strong>, only <strong>global uniqueness</strong>, which is naive but isn&rsquo;t too far off more sophisticated schemes <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>genNaive</span><span class=p>(</span><span class=nx>nodeID</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>requestID</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>FormatInt</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Int63n</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>sequenceId</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>FormatInt</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixMicro</span><span class=p>(),</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>originId</span> <span class=o>:=</span> <span class=nx>nodeID</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>identity</span> <span class=o>:=</span> <span class=nx>originId</span> <span class=o>+</span> <span class=nx>requestID</span> <span class=o>+</span> <span class=nx>sequenceId</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>ParseInt</span><span class=p>(</span><span class=nx>identity</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>64</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>id</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li><p>hash a seed over a really large key space (2**128 - 1) - a uuid.</p></li><li><p>The use of a central authority such as an atomic clock or a &ldquo;time server&rdquo;.</p></li></ol><h2 id=3-broadcast>3. Broadcast</h2><p>Our first &ldquo;official&rdquo; distributed algorithm! a way to gossip information to nodes. Incrementally we scaffold basic messaging,
sending data efficiently, simulating network partitions, variable latencies and interesting node topologies!</p><p>We keep all data we&rsquo;ve seen in-memory in a simple &ldquo;store&rdquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Store</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>index</span> <span class=kd>map</span><span class=p>[</span><span class=kt>float64</span><span class=p>]</span><span class=kt>bool</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span>   <span class=p>[]</span><span class=kt>float64</span>
</span></span><span class=line><span class=cl>	<span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a session is an instance of a node
</span></span></span><span class=line><span class=cl><span class=c1>// that can read/write from a single-store
</span></span></span><span class=line><span class=cl><span class=c1>// and `handle` messages
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Session</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>node</span>  <span class=o>*</span><span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>store</span> <span class=o>*</span><span class=nx>Store</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>reading, we simply take a <code>read</code> lock, respond with what&rsquo;s in our <code>log</code> so far.</p><p>If we get a <code>broadcast</code> message we concurrently attempt to send it to all our neighbours, excluding ourself, store it in <code>log</code> and <code>index</code> so we can test if we&rsquo;ve seen this message before and handle duplicate broadcasts:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>dest</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>n</span><span class=p>.</span><span class=nf>NodeIDs</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>400</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>bgd</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>bgd</span><span class=p>,</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>dest</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nf>SyncRPC</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>dest</span><span class=p>,</span> <span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// failure detection up next!
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}(</span><span class=nx>dest</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span></code></pre></div><p>Our failure detection algorithm is a FIFO queue using go&rsquo;s channels, so we can handle network partitions and variable latency!
We send messages into a buffered channel, in our else block:</p><pre tabindex=0><code>s.retries &lt;- Retry{body: body, dest: dest, attempt: 40, exec: n.Send, err: err}
</code></pre><p>What suprised me is the configuration of this queue. Too small and messages will be dropped, too big and the failureDetector
will never catch up.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>failureDetector</span><span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Node</span><span class=p>,</span> <span class=nx>retries</span> <span class=kd>chan</span> <span class=nx>Retry</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>retry</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>retries</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>retry</span> <span class=nx>Retry</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>400</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>bgd</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>bgd</span><span class=p>,</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		  <span class=nx>etry</span><span class=p>.</span><span class=nx>attempt</span><span class=o>--</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>attempt</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nf>SyncRPC</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>dest</span><span class=p>,</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>jitter</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>500</span><span class=p>)</span> <span class=o>+</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>jitter</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nx>retries</span> <span class=o>&lt;-</span> <span class=nx>retry</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			  <span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;silent message loss from queue %v&#34;</span><span class=p>,</span> <span class=nx>retry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}(</span><span class=nx>retry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and finally our topology to minimise all those wasted sent messages:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go></code></pre></div><h2 id=4-grow-only-counter>4. Grow-Only Counter</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go></code></pre></div><h2 id=5-kafka-style-log>5. Kafka-Style Log</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go></code></pre></div><h2 id=6-totally-available-transactions>6. Totally-Available Transactions</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go></code></pre></div><h3 id=references>References</h3><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://datatracker.ietf.org/doc/html/rfc4122#section-4.2.1>https://datatracker.ietf.org/doc/html/rfc4122#section-4.2.1</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://en.wikipedia.org/wiki/Snowflake_ID>https://en.wikipedia.org/wiki/Snowflake_ID</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>source</a>
Copyright © 2024 Haile Lagi<div id=sign-key><span>GPG key ID: 0298F4203ADC85E8</span></div></footer></body></html>