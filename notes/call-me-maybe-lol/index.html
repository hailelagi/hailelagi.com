<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A repository for my thoughts"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.css><meta name=title property=”og:title” content="Oops - Call Me Maybe? | Haile (ሐይሌ)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Oops - Call Me Maybe? | Haile (ሐይሌ)"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta name=twitter:creator content="@hailelagi"><title>Oops - Call Me Maybe?</title></head><body><header id=banner><h2><a href=https://www.hailelagi.com/>Haile (ሐይሌ)</a></h2><nav><ul><li><a href=/bookshelf title=bookshelf>bookshelf</a></li><li><a href=https://www.github.com/hailelagi title=github>github</a></li><li><a href=/notes title=writing>writing</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Oops - Call Me Maybe?</h1><time>May 19, 2024</time><meta name=twitter:card content="summary">
<meta property="og:url" content="https://www.hailelagi.com/"><meta property="og:image" content="/favicon-32x32.png"><meta itemprop=image content="/favicon-32x32.png"><meta name=twitter:image content="/favicon-32x32.png"><meta name=twitter:image:src content="/favicon-32x32.png"></header><p>I&rsquo;m solving the fly.io distributed systems challenges for practice while reading part II of database internals with the <a href=https://x.com/sysdsgn>sysdsgn bookclub</a>.</p><p>The title of this post is inspired by <a href=https://aphyr.com/posts/316-call-me-maybe-etcd-and-consul>kyle kingsbury&rsquo; series of articles like this one</a> and <a href=https://aphyr.com/posts/315-call-me-maybe-rabbitmq>this one</a>. I thought it&rsquo;d also be funny to play it on repeat while solving/writing some of this :)</p><iframe src=https://open.spotify.com/embed/track/20I6sIOMTCkB6w7ryavxtO width=100% height=380 frameborder=0 allowtransparency=true allow=encrypted-media></iframe><h2 id=1-echo>1. echo</h2><p>saying hello world! but distributed systems style, it&rsquo;s mostly boilerplate setup,
reading the maelstrom docs and the go client docs, we instantiate a maelstrom node/binary, define an RPC style handler and return messages:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=o>:=</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nf>NewNode</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Register a handler for the &#34;echo&#34; message that responds with an &#34;echo_ok&#34;.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>n</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=s>&#34;echo&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>msg</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Unmarshal the message body as an loosely-typed map.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kd>var</span> <span class=nx>body</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Update the message type.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>body</span><span class=p>[</span><span class=s>&#34;type&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;echo_ok&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Echo the original message back with the updated message type.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Execute the node&#39;s message loop. This will run until STDIN is closed.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nf>Run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;ERROR: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=2-unique-id-generation-what-time-is-it>2. Unique ID Generation (What time is it?)</h2><p>In a single node/computer, generation of unique ids is typically achieved using a growing monontonic sequence such as a counter or the system clock.</p><p>In the view of a distributed system where each node could increment this counter simultaneously and the <a href=https://tigerbeetle.com/blog/three-clocks-are-better-than-one>the system clock is unreliable</a> there needs to be some way of solving this <a href="https://www.youtube.com/watch?v=mAyW-4LeXZo">global clock synchronisation problem</a> of not only skewing different &ldquo;times&rdquo; but logical ordering of events. What to do? We also want to prevent the need to exchange messages or co-ordination so lamport clocks are out!</p><ol><li>A pseudo logical event clock where we can represent casual dependencies as combinations of properties of our system for e.g the system clock + orignating node id + a random request id(tie breaker). Luckily for this challenge there aren&rsquo;t requirements for <strong>space</strong> or <strong>ordering</strong> or <strong>causality</strong>, only <strong>global uniqueness</strong>, which is naive but isn&rsquo;t too far off more sophisticated schemes <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>genNaive</span><span class=p>(</span><span class=nx>nodeID</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>requestID</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>FormatInt</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Int63n</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>sequenceId</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>FormatInt</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixMicro</span><span class=p>(),</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>originId</span> <span class=o>:=</span> <span class=nx>nodeID</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>identity</span> <span class=o>:=</span> <span class=nx>originId</span> <span class=o>+</span> <span class=nx>requestID</span> <span class=o>+</span> <span class=nx>sequenceId</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>ParseInt</span><span class=p>(</span><span class=nx>identity</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>64</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>id</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li><p>hash a seed over a really large key space (2**128 - 1) - a uuid.</p></li><li><p>The use of a central authority, such as an atomic clock + GPS and/or other clever distributed algorithms<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> provided by a <a href=https://cloud.google.com/spanner/docs/true-time-external-consistency>time server(s)</a>.</p></li></ol><h2 id=3-broadcast>3. Broadcast</h2><p>Our first &ldquo;official&rdquo; distributed algorithm! a way to gossip information to nodes. Incrementally we scaffold basic messaging,
sending data efficiently, simulating network partitions, variable latencies and interesting node topologies!</p><p>We keep all data we&rsquo;ve seen in-memory in a simple &ldquo;store&rdquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>store</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>index</span> <span class=kd>map</span><span class=p>[</span><span class=kt>float64</span><span class=p>]</span><span class=kt>bool</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span>   <span class=p>[]</span><span class=kt>float64</span>
</span></span><span class=line><span class=cl>	<span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// a session is an instance of a node
</span></span></span><span class=line><span class=cl><span class=c1>// that can read/write from a single-store
</span></span></span><span class=line><span class=cl><span class=c1>// and `handle` messages
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>session</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>node</span>    <span class=o>*</span><span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=nx>store</span>   <span class=o>*</span><span class=nx>store</span>
</span></span><span class=line><span class=cl>	<span class=nx>retries</span> <span class=kd>chan</span> <span class=nx>retry</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>reading, we simply take a <code>read</code> lock, respond with what&rsquo;s in our <code>log</code> so far.</p><p>If we get a <code>broadcast</code> message we concurrently attempt to send it to all our neighbours, excluding ourself, store it in <code>log</code> and <code>index</code> so we can test if we&rsquo;ve seen this message before and short circuit duplicate broadcasts:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// spam everyone in this network we know of, and so on...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>dest</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>n</span><span class=p>.</span><span class=nf>NodeIDs</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>200</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>bgd</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>bgd</span><span class=p>,</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>dest</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nf>SyncRPC</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>dest</span><span class=p>,</span> <span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// failure detection up next!
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}(</span><span class=nx>dest</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span></code></pre></div><p>Our failure detection algorithm is a simple FIFO queue using go&rsquo;s channels, for the un-initiated in go-ism, it&rsquo;s conceputally an <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.22.3:src/runtime/chan.go;l=33">&ldquo;atomic circular buffer&rdquo;</a>, if that doesn&rsquo;t mean much &ndash; it&rsquo;s a &lsquo;concurrent safe queue&rsquo;, so we can handle network partitions and variable latency async!
We send messages into a buffered channel, in our else block and read it (if/when) we have to retry in a seperate goroutine(s):</p><pre tabindex=0><code>s.retries &lt;- Retry{body: body, dest: dest, attempt: 20, err: err}
</code></pre><p>we guess-timate a queue size (I&rsquo;m not 100% about this bit lmk if I&rsquo;m wrong!):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> little&#39;s law: L (num units) = arrival rate * wait time
</span></span></span><span class=line><span class=cl><span class=cm> rate == 100 msgs/sec assuming efficient workload,
</span></span></span><span class=line><span class=cl><span class=cm> latency/wait mininum = 100ms, 400ms average
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> 100 * 0.4 = 40 msgs per request * 25 - 1(self) nodes 
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> = 960 queue size, will use ~1000
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>retries</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>retry</span><span class=p>,</span> <span class=mi>1000</span><span class=p>)</span>
</span></span></code></pre></div><p>The spurious errors and on/off successes and failures making this were&mldr; interesting to debug! non-deterministic systems are&mldr; something.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// a naive failure detector :)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>failureDetector</span><span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>session</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>r</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span><span class=p>.</span><span class=nx>retries</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span> <span class=o>:=</span> <span class=nx>r</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>retry</span> <span class=nx>retry</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>200</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>retry</span><span class=p>.</span><span class=nx>attempt</span><span class=o>--</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>attempt</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>SyncRPC</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>dest</span><span class=p>,</span> <span class=nx>retry</span><span class=p>.</span><span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>retry</span><span class=p>.</span><span class=nx>attempt</span><span class=p>)</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nx>s</span><span class=p>.</span><span class=nx>retries</span> <span class=o>&lt;-</span> <span class=nx>retry</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>log</span><span class=p>.</span><span class=nf>SetOutput</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;dead letter message slip loss beyond tolerance %v&#34;</span><span class=p>,</span> <span class=nx>retry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>A perfect timeout-based failure detector exists only in a synchronous crash-stop system with reliable
links; in a partially synchronous system, a perfect failure detector does not exist</p><p>&ndash; <a href=https://www.cl.cam.ac.uk/teaching/2122/ConcDisSys/dist-sys-handout.pdf>https://www.cl.cam.ac.uk/teaching/2122/ConcDisSys/dist-sys-handout.pdf</a></p></blockquote><p>and finally we optimise! we&rsquo;re sending far too many messages and flooding the entire network! even if it&rsquo;s impossible to be both accurate and fast,
we try anyway &ndash; gotta get those p99s up, so far these are rookie numbers! there&rsquo;s a hint about network topology so let&rsquo;s re-examine that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>The neighbors Maelstrom suggests are, by default, arranged in a two-dimensional grid.
</span></span></span><span class=line><span class=cl><span class=cm>This means that messages are often duplicated en route to other nodes, and latencies
</span></span></span><span class=line><span class=cl><span class=cm>are on the order of 2 * sqrt(n) network delays.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>neighbors</span> <span class=p>[]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>session</span><span class=p>)</span> <span class=nf>topologyHandler</span><span class=p>(</span><span class=nx>msg</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>body</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>self</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>ID</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>topology</span> <span class=o>:=</span> <span class=nx>body</span><span class=p>[</span><span class=s>&#34;topology&#34;</span><span class=p>].(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>neighbors</span> <span class=p>=</span> <span class=nx>topology</span><span class=p>[</span><span class=nx>self</span><span class=p>].([]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nx>node</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>{</span><span class=s>&#34;type&#34;</span><span class=p>:</span> <span class=s>&#34;topology_ok&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>For this bit, I had to draw up the messsaging flow of the network topology on pen and paper. First I tried to send only to immediately connected neighbours. For example in a 5 node cluster of <code>a, b, c, d, e</code> a would neighbour <code>b, c</code> and so on forming the 2x2 grid. This was too unreliable and lost messages.</p><p>Database Internals chapter 12 was also super helpful on where to go about exploring options, network topologies are a deep topic, so we&rsquo;ll only review a very tiny subset we&rsquo;re interested in:</p><ol><li>a fully connected grid mesh (what we had before) <a href=https://en.wikipedia.org/wiki/Network_topology>to quote wikipedia</a>:</li></ol><blockquote><p>Networks designed with this topology are usually very expensive to set up, but provide a high degree of reliability due to the multiple paths for data that are provided by the large number of redundant links between nodes</p></blockquote><ol start=2><li>a tree topology - let&rsquo;s revisit spanning trees. We&rsquo;re presented with seemingly contradictory goals - fast low-latency and reliable accurate broadcast, in a large partitioned network.</li></ol><h2 id=4-grow-only-counter>4. Grow-Only Counter</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go></code></pre></div><h2 id=5-kafka-style-log>5. Kafka-Style Log</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go></code></pre></div><h2 id=6-totally-available-transactions>6. Totally-Available Transactions</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go></code></pre></div><h3 id=references>References</h3><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://datatracker.ietf.org/doc/html/rfc4122#section-4.2.1>https://datatracker.ietf.org/doc/html/rfc4122#section-4.2.1</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://en.wikipedia.org/wiki/Snowflake_ID>https://en.wikipedia.org/wiki/Snowflake_ID</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=http://yellerapp.com/posts/2015-02-09-flake-ids.html>http://yellerapp.com/posts/2015-02-09-flake-ids.html</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://www.cockroachlabs.com/blog/living-without-atomic-clocks/>https://www.cockroachlabs.com/blog/living-without-atomic-clocks/</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main><footer id=footer><a href=https://github.com/hailelagi/blog>Copyright © 2024 Haile Lagi</a><div><span>private inquiries: hailelagi[at]gmail.com</span></div><div><span>or informally(twitter/x): https://x.com/haile_lagi</span></div></footer></body></html>